{% extends 'syncapp/base.html' %}
{% load static %}
{% load i18n %}
{% block title %}Consumers Map{% endblock %}

{% block extra_head %}
<script src="https://code.jquery.com/jquery-3.7.1.min.js"></script>

<link
  rel="stylesheet"
  href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
/>
<link
  rel="stylesheet"
  href="https://unpkg.com/leaflet.markercluster@1.5.3/dist/MarkerCluster.css"
/>
<link
  rel="stylesheet"
  href="https://unpkg.com/leaflet.markercluster@1.5.3/dist/MarkerCluster.Default.css"
/>
<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<script src="https://unpkg.com/leaflet.markercluster@1.5.3/dist/leaflet.markercluster.js"></script>
<link rel="stylesheet" href="{% static 'syncapp/css/map.css' %}">

<script src="https://cdn.jsdelivr.net/npm/chart.js@4.3.0/dist/chart.umd.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-zoom@2.0.1/dist/chartjs-plugin-zoom.min.js"></script>

<script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.4.1/papaparse.min.js"></script>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nouislider@15.7.0/dist/nouislider.min.css" />
<script src="https://cdn.jsdelivr.net/npm/nouislider@15.7.0/dist/nouislider.min.js"></script>

<link
  rel="stylesheet"
  href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css"
/>
<script src="https://cdn.jsdelivr.net/npm/sweetalert2@11"></script>

<link href="https://cdn.jsdelivr.net/npm/nouislider@15.7.0/dist/nouislider.min.css" rel="stylesheet">
<script src="https://cdn.jsdelivr.net/npm/nouislider@15.7.0/dist/nouislider.min.js"></script>

<style>
  main {
  display: block !important; /* disable flex for main */
}
  
  .resizable-chart {
    width: 100% !important;
    max-height: 300px;
    transition: max-height 0.3s ease;
  }

  .resizable-chart.expanded {
    max-height: 600px;
  }
  .toggle-chart-btn {
  font-size: 0.8rem;
  background-color: #f8f9fa;
  border: 1px solid #ccc;
  border-radius: 5px;
  padding: 2px 8px;
  margin-left: 10px;
  cursor: pointer;
  transition: background 0.2s ease;
}
.toggle-chart-btn:hover {
  background-color: #e2e6ea;
}
.chart-container {
  width: 100%;
  height: 300px;              /* default compact height */
  transition: height 0.28s ease;
  position: relative;
}

/* make the canvas fill the container */
.chart-container canvas {
  width: 100% !important;
  height: 100% !important;    /* Chart.js respects canvas height property */
  display: block;
}

/* expanded state */
.chart-container.expanded {
  height: 600px;              /* expanded height */
}
#dateRangeSlider {
  margin-top: 10px;
}
.noUi-handle {
  background-color: #007bff;
  border: 2px solid #0056b3;
  box-shadow: none;
}
.noUi-connect {
  background: #80bdff;
}

.chart-slider {
  width: 100%;
}
.noUi-target {
  background: #e9ecef;
  border-radius: 5px;
  height: 8px;
}
.noUi-handle {
  background: #007bff;
  border: none;
  box-shadow: 0 0 5px rgba(0,0,0,0.3);
  width: 16px;
  height: 16px;
  top: -4px;
}
.noUi-connect {
  background: #007bff;
}


#split-container {
  display: flex;
  width: 100%;
  height: calc(100vh - 120px);
  overflow: hidden;
}

#map-container {
  flex: 0 0 55%;
  min-width: 25%;
  transition: flex-basis 0.1s ease;
}

#divider {
  width: 6px;
  background: #ccc;
  cursor: col-resize;
  flex-shrink: 0;
}

#right-panel {
  flex: 0 0 45%;
  overflow-y: auto;
  background: #f9f9f9;
}
#map-container { outline: 1px dashed rgba(0,0,0,0.08); }
#right-panel { outline: 1px dashed rgba(0,0,0,0.08); }
#divider { outline: 1px solid rgba(0,0,0,0.06); }
</style>
{% endblock %}

{% block content %}
<!-- Login Modal -->
<div id="loginModal" style="display:block; position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.5); z-index:1000;">
  <div style="background:white; padding:20px; margin:100px auto; width:300px; border-radius:5px;">
    <h3>Login</h3>
    <form id="loginForm">
      <input type="text" id="username" placeholder="Username" required style="width:100%; margin-bottom:10px;">
      <input type="password" id="password" placeholder="Password" required style="width:100%; margin-bottom:10px;">
      <button type="submit" style="width:100%;">Login</button>
    </form>
    <div id="loginMessage" style="margin-top:10px; color:red;"></div>
  </div>
</div>

<div id="split-container">
<div id="map-container">
 <div id="map"></div>
  <div id="map-controls">
    <label for="commoditySelect"><b>Select Commodity</b></label>
    <select id="commoditySelect" class="form-control">
      {% for type, items in grouped_commodities.items %}
        <optgroup label="{{ type }}">
          {% for item in items %}
            <!-- <option value="{{ item.name }}" {% if item.disabled %}disabled{% endif %}>
              {{ item.name }}
            </option> -->
             <option value="{{ item.name }}"
                  {% if item.name == "Onion" %}selected{% endif %} 
                  {% if item.disabled %}disabled{% endif %}>
            {{ item.name }}
          </option>
          {% endfor %}
        </optgroup>
      {% endfor %}
    </select>
        
    <!-- Show total commodity count -->
    <p id="commodityCount" style="margin-top: 5px; font-weight: bold; color: #333;"></p>
    <hr>
      <div id="date-range-container" style="margin-bottom: 10px;">
      <label>Start Date:</label>
      <input type="date" id="startDate" class="form-control" style="margin-bottom: 5px; font-size: 12px;">

      <label>End Date:</label>
      <input type="date" id="endDate" class="form-control" style="margin-bottom: 5px; font-size: 12px;">

      <button id="filterByDateBtn" class="btn btn-primary btn-sm" style="width: 100%;">Filter</button>
    </div>
  <hr>
    <div id="left-panel">
      <button id="locateBtn" title="My Location">
        <i class="fas fa-crosshairs"></i>
        </button>
      <label>Radius: <span id="radiusValue">100</span></label>
      <input type="range" id="radiusSlider" min="1" max="8" value="2" step="1" list="tickmarks">
        <datalist id="tickmarks">
        <option value="1" label="50 m"></option>
        <option value="2" label="100 m"></option>
        <option value="3" label="500 m"></option>
        <option value="4" label="1 km"></option>
        <option value="5" label="5 km"></option>
        <option value="6" label="20 km"></option>
        <option value="7" label="100 km"></option>
        <option value="8" label="500 km"></option>
        </datalist>
        <div id="radius-stats" style="margin-top: 4px;">
        <strong>Within Selected Radius:</strong><br>
        Average Price: <span id="avg-price-radius">--</span><br>
        Modal Price: <span id="modal-price-radius">--</span>
      </div>
    </div>
    <hr>
    <button id="toggleDistrictBtn">üó∫Ô∏è Hide Districts</button>
    <!-- <hr> -->
    <!-- <button id="toggleApmcBtn">üõí Show All APMC</button> -->
  </div>
  <button id="toggle-map-controls">‚öôÔ∏è Hide/Show</button>
</div>
  <div id="divider"></div>
<div id="right-panel">
  <div class="box" id="graph-box">
    <!-- <h3>Charts for : 
      <span id="selected-commodity"></span>
    </h3> -->
    <div id="stats-container" style="display: flex; gap: 20px;">
      <div id="global-stats" style="margin-top: 4px;display:none;">
        <strong>All Consumers:</strong><br>
        Average Price: <span id="avg-price">--</span><br>
        Weighted Average: <span id="weighted-avg">--</span><br>
        Modal Price: <span id="modal-price">--</span>
      </div> 
      <div id="radius-stats1" style="margin-top: 4px;display:none;">
        <strong>Within Selected Radius:</strong><br>
        Average Price: <span id="avg-price-radius">--</span><br>
        Weighted Average: <span id="weighted-avg-radius">--</span><br>
        Modal Price: <span id="modal-price-radius">--</span>
      </div>
    </div> <!--# stats-container div close -->
    <!-- <hr> -->
    <div style="text-align: right; margin-bottom: 10px;">
      <button id="openAllChartsBtn" class="btn btn-primary">‚ÜóÔ∏è Open Charts</button>
    </div>
    
    
    <h3><b>Consumer and Farmer Reported Price Trend : 
      <span id="selected-commodity"></span></b>
      <span id="consumerapan"></span>
      <button class="toggle-chart-btn" data-target="consumersChart">Hide Chart</button>
      <!-- <button class="resize-chart-btn" data-target="consumersChart">Expand</button> -->
    </h3>
     
      <canvas id="consumersChart" class="resizable-chart"></canvas>
      <div class="chart-footer">
      <div class="chart-slider mt-3 px-3">
        <label for="dateRangeSlider" class="form-label fw-bold">{% trans "Adjust Date Range" %}</label>
        <div id="dateRangeSlider"></div>
        
        <div class="d-flex justify-content-between mt-2 text-muted small">
          <span id="sliderStartLabel">Start Date</span>
          <span id="sliderEndLabel">End Date</span>
        </div>
      </div>
      <br>
      <p class="chart-tip">üí° {% trans "Tip: Scroll to zoom, drag (or Ctrl + drag) to pan." %}</p>

      <hr>
     
    <h3><b>Agmarknet Price Trend :
      <span id="selected-commodity"></span></b>
      <span id="agmarknet"></span>
      <button class="toggle-chart-btn" data-target="chartCanvas">Hide Chart</button>
      <!-- <button class="resize-chart-btn" data-target="chartCanvas">Expand</button> -->
    </h3>
    
     <div class="chart-x-slider-container">
      <canvas id="chartCanvas"></canvas>
      <div class="chart-footer1">
      <div class="chart-slider mt-3 px-3">
        <label for="dateRangeSlider" class="form-label fw-bold">{% trans "Adjust Date Range" %}</label>
        <div id="dateRangeSlider1"></div>
        
        <div class="d-flex justify-content-between mt-2 text-muted small">
          <span id="sliderStartLabel1">Start Date</span>
          <span id="sliderEndLabel1">End Date</span>
        </div>
      </div>
      <br>
      <p class="chart-tip">üí° {% trans "Tip: Scroll to zoom, drag (or Ctrl + drag) to pan." %}</p>
       <!-- Dual slider -->
      <div id="dateRangeSlider" style="margin: 20px auto; width: 90%;"></div>
      <div id="dateRangeLabel" style="text-align:center; margin-top: 6px; font-size: 0.9rem;"></div>
    </div>
  </div><!--# graph-box div close -->
</div><!--# <right>-panel div close -->
</div> <!--split container close-->
{% endblock %}

{% block extra_js %}
<script>
const USER_LOGGED_IN = "{{ user.is_authenticated|yesno:'true,false' }}" === "true";
document.addEventListener("DOMContentLoaded", function() {
  // Wait until modal exists, then check login state
  const loginModal = document.getElementById("loginModal");
  const loginForm = document.getElementById("loginForm");
  const loginMessage = document.getElementById("loginMessage");

// RESIZE the map and left panel
const divider = document.getElementById("divider");
  const left = document.getElementById("map-container");
  const right = document.getElementById("right-panel");
  const container = document.getElementById("split-container");
  const map = document.getElementById("map");

  let isResizing = false;
  let startX = 0;
  let startLeftFlex = 0;

  divider.addEventListener("mousedown", (e) => {
    isResizing = true;
    startX = e.clientX;
    // calculate initial left flex percentage
    startLeftFlex = (left.offsetWidth / container.offsetWidth) * 100;
    document.body.style.cursor = "col-resize";
    document.body.style.userSelect = "none";
  });

  window.addEventListener("mousemove", (e) => {
    if (!isResizing) return;
    const dx = e.clientX - startX;
    const newLeftPercent = ((left.offsetWidth + dx) / container.offsetWidth) * 100;

    // clamp to reasonable limits (min 25%, max 75%)
    const clamped = Math.min(75, Math.max(25, newLeftPercent));
    left.style.flex = `0 0 ${clamped}%`;
    right.style.flex = `0 0 ${100 - clamped}%`;

    // refresh leaflet map dynamically if available
    if (window.myLeafletMap) {
      window.myLeafletMap.invalidateSize();
    }
  });

  window.addEventListener("mouseup", () => {
    isResizing = false;
    document.body.style.cursor = "default";
    document.body.style.userSelect = "auto";
  });

  // REsize over

  const endDateInput = document.getElementById("endDate");
  const startDateInput = document.getElementById("startDate");

  // helper: convert date to yyyy-mm-dd
  function toISO(d) {
    return d.toISOString().split("T")[0];
  }

  // helper: convert date to dd-mm-yyyy (for display or debug)
  function toDDMMYYYY(d) {
    return `${String(d.getDate()).padStart(2, "0")}-${String(d.getMonth() + 1).padStart(2, "0")}-${d.getFullYear()}`;
  }

  const today = new Date();
  const priorDate = new Date();
  priorDate.setDate(today.getDate() - 95);

  // ‚úÖ assign ISO values to date inputs
  endDateInput.value = toISO(today);
  startDateInput.value = toISO(priorDate);

  console.log("Start date (DD-MM-YYYY):", toDDMMYYYY(priorDate));
  console.log("End date (DD-MM-YYYY):", toDDMMYYYY(today));
  // üîπ Optional: automatically trigger data filter on load
  document.getElementById("filterByDateBtn").click();
    Chart.register(ChartZoom);

  

  const apmcCsvUrl = "{% static 'APMC_names.csv' %}";
  let apmcMarkers = L.layerGroup();  // Separate layer for APMC

//   const toggleApmcBtn = document.getElementById("toggleApmcBtn");
  let apmcVisible = false;

  const apmcIcon = L.icon({
    iconUrl: "{% static 'apmcM.png' %}",
    iconSize: [30, 30], // width, height
    iconAnchor: [15, 30], // point of the icon which will correspond to marker's location
    popupAnchor: [0, -30] // point from which the popup opens relative to the iconAnchor
  });

  
  // --------------------------
  // Token helpers 
  // --------------------------
  async function refreshToken(){
      const refresh = sessionStorage.getItem("refresh_token");
      if(!refresh) return false;
      try {
          const res = await fetch("/api/token/refresh/", {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({ refresh })
          });
          if(res.ok){
              const data = await res.json();
              sessionStorage.setItem("api_token", data.access);
              return true;
          } else {
              console.warn("Refresh token failed");
              return false;
          }
      } catch(err){
          console.error("Refresh token error:", err);
          return false;
      }
  }

  async function authFetch(url, options={}, retry=true){
    const token = sessionStorage.getItem("api_token");
    if(!token) throw new Error("No API token available");

    options.headers = {...options.headers,"Authorization":`Bearer ${token}`,"Content-Type":"application/json"};

    try {
        const res = await fetch(url, options);

        if(res.status === 401 && retry){
            const ok = await refreshToken();
            if(ok) return authFetch(url, options, false);
            else { 
                loginModal.style.display="block"; 
                throw new Error("Session expired, login required"); 
            }
        }

        if(res.status >= 400){ 
            try { return await res.json(); } catch(e){ return {}; }
        }

        return await res.json();

    } catch(err){
        console.error("authFetch error", err);
        return {}; 
    }
  }

  // --------------------------
  // Agrowon & Agmark fetch functions
  // --------------------------
    let agmarkChart = null;
    let agmarkData = [];

// --------------------------
  // Login form 
  // --------------------------
  loginForm.addEventListener("submit", async function (e) {
    e.preventDefault();
    const username = document.getElementById("username").value;
    const password = document.getElementById("password").value;

    try {
      const res = await fetch("/api/token/", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ username, password }),
      });
      const data = await res.json();
      if(data.access){
        if(!sessionStorage.getItem("api_token") && localStorage.getItem("api_token")){
            sessionStorage.setItem("api_token", localStorage.getItem("api_token"));
            sessionStorage.setItem("refresh_token", localStorage.getItem("refresh_token"));
            sessionStorage.setItem("username", localStorage.getItem("username"));
        } 
          localStorage.setItem("username", username);
          localStorage.setItem("api_token", data.access);
          localStorage.setItem("refresh_token", data.refresh);
          loginModal.style.display = "none";
          initMap();
          window._leaflet_map = map;
      } else {
          loginMessage.innerText = data.detail || "Login failed!";
      }
    } catch(err){
        console.error("Login error:", err);
        loginMessage.innerText = "Login failed! Check console.";
    }
  });

  // --------------------------
  // Auto-login check 
  // --------------------------
  (function syncTokens() {
    if (!sessionStorage.getItem("api_token") && localStorage.getItem("api_token")) {
        sessionStorage.setItem("api_token", localStorage.getItem("api_token"));
        sessionStorage.setItem("refresh_token", localStorage.getItem("refresh_token"));
        sessionStorage.setItem("username", localStorage.getItem("username"));
    }
})();
  (async function autoLoginCheck() {
    const token = sessionStorage.getItem("api_token");
    const refresh = sessionStorage.getItem("refresh_token");
    const username = sessionStorage.getItem("username");

    if(token) {
        // Try to use the token
        try {
            // Test a simple API endpoint to see if token is valid
            const res = await fetch("/api/consumers_geojson/", {
                headers: { "Authorization": `Bearer ${token}` }
            });
            if(res.ok){
                loginModal.style.display = "none";
                initMap();
                return;
            } 
        } catch(err){
            console.warn("Token check failed:", err);
        }
    }

    // Token invalid or missing, try refresh
    if(refresh){
        const ok = await refreshToken();
        if(ok){
            loginModal.style.display = "none";
            initMap();
            return;
        }
    }

    // No valid token or refresh -> show login modal
    loginModal.style.display = "block";
  })();



  // --------------------------
  // Map initialization
  // --------------------------
  async function initMap(){
      const commoditySelect = document.getElementById("commoditySelect");
      const selectedCommoditySpan = document.getElementById("selected-commodity");
      selectedCommoditySpan.innerText = commoditySelect.value;

      const map = L.map('map',{ zoomControl: false }).setView([19.2, 73.0], 7);

      const osm = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { attribution: '&copy; OpenStreetMap' });
    //   const googleSat = L.tileLayer('https://mt1.google.com/vt/lyrs=s&x={x}&y={y}&z={z}', { attribution: '&copy; Google' });
      const googleSat= L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Street_Map/MapServer/tile/{z}/{y}/{x}', {
      attribution: '&copy; Esri, HERE, Garmin, ¬© OpenStreetMap contributors'
      });
      const googleSat1 = L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/Reference/World_Boundaries_and_Places/MapServer/tile/{z}/{y}/{x}', {
      maxZoom: 19,
      attribution: ''
      });
      //googleSat.addTo(map);
      osm.addTo(map);
      const satelliteWithBoundaries = L.layerGroup([googleSat, googleSat1]);
      const baseMaps = { "OpenStreetMap": osm, "Google Satellite": googleSat };
    //   const baseMaps = { "OpenStreetMap": osm, "Google Satellite": googleSat };
      L.control.layers(baseMaps, null, { position: 'topright' }).addTo(map);
      L.control.zoom({ position: 'topright' }).addTo(map);

      const markers = L.markerClusterGroup();
      let geojsonLayer = null;
      let allData = null;
      let userLocation = null;
      let userMarker = null;
      let radiusCircle = null;

      const radiusSlider = document.getElementById("radiusSlider");
      const radiusValue = document.getElementById("radiusValue");
      const scale = {
                    1: 50,
                    2: 100,
                    3: 500,
                    4: 1000,
                    5: 5000,
                    6: 20000,
                    7: 100000,
                    8: 500000
        };

      function drawCircle(radius){
          if(!userLocation) return;
          if(radiusCircle) map.removeLayer(radiusCircle);
          radiusCircle = L.circle(userLocation, { radius: radius, color:"red", fillOpacity:0.05 }).addTo(map);
      }

      function computeStats(features, center=null, radius=null){
          let filtered = features;
          if(center && radius){
              filtered = features.filter(f=>{
                  const latlng = L.latLng(f.geometry.coordinates[1], f.geometry.coordinates[0]);
                  return center.distanceTo(latlng)<=radius;
              });
          }
          if(filtered.length === 0) return {avg:null, weighted:null, modal:null};
          const prices = filtered.map(f=>f.properties.buyingprice).filter(v=>v!==null);
          const unit = filtered.map(f => f.properties.unit).find(u => u !== null && u !== undefined) || '';
          const quantities = filtered.map(f=>f.properties.quantitybought).map(q=>q||1);
          const avg = prices.reduce((a,b)=>a+b,0)/prices.length;
          const weighted = prices.reduce((sum,p,i)=>sum+p*quantities[i],0)/quantities.reduce((a,b)=>a+b,0);
          const freq={}; prices.forEach(p=>freq[p]=(freq[p]||0)+1);
          let modal=prices[0], maxCount=0;
          for(const k in freq){ if(freq[k]>maxCount){ modal=k; maxCount=freq[k]; } }
          return {avg, weighted, modal};
      }

      function showGlobalStats(stats){
          document.getElementById("avg-price").innerText = stats.avg!==null ?` ‚Çπ${stats.avg.toFixed(2)} ${stats.unit || ''}`: "No data";
          document.getElementById("weighted-avg").innerText = stats.weighted!==null ? stats.weighted.toFixed(2) : "No data";
          document.getElementById("modal-price").innerText = stats.modal!==null ? `‚Çπ${stats.modal}` : "No data";
      }

      function showRadiusStats(stats){
          document.getElementById("avg-price-radius").innerText = stats.avg!==null ? stats.avg.toFixed(2) : "No data";
          document.getElementById("weighted-avg-radius").innerText = stats.weighted!==null ? stats.weighted.toFixed(2) : "No data";
          document.getElementById("modal-price-radius").innerText = stats.modal!==null ? stats.modal : "No data";
      }

      function updateStatsForRadius(){
        if(!allData || !Array.isArray(allData.features)) return;
        const commodity = commoditySelect.value.toLowerCase();
        const filtered = allData.features.filter(f => f.properties?.commodity?.toLowerCase() === commodity);
        showGlobalStats(computeStats(filtered));
        if(userLocation) showRadiusStats(computeStats(filtered, userLocation, scale[radiusSlider.value]));
        else showRadiusStats({avg:null, weighted:null, modal:null});
      }

      function updateMarkers(commodity, zoomToBounds=false){
          markers.clearLayers();
          if(geojsonLayer) map.removeLayer(geojsonLayer);
          if(!allData || !Array.isArray(allData.features)) return;

          const indiaBounds = L.latLngBounds([6.5,68.0],[35.5,97.5]);

// // Filter Map based on date range added
            const startDateInput = document.getElementById("startDate").value;
            const endDateInput = document.getElementById("endDate").value;
            const startDate = startDateInput ? new Date(startDateInput) : null;
            const endDate = endDateInput ? new Date(endDateInput) : null;

            const filteredFeatures = allData.features.filter(f => {
                const latlng = L.latLng(f.geometry.coordinates[1], f.geometry.coordinates[0]);
                const dbName = f.properties.commodity?.trim().toLowerCase();
                const selected = commodity.trim().toLowerCase();

                // Skip if location not in India bounds or commodity mismatch
                if (!indiaBounds.contains(latlng) || dbName !== selected) return false;

                // Filter by date range if available
                if (f.properties.date) {
                    const recordDate = new Date(f.properties.date);
                    if (startDate && recordDate < startDate) return false;
                    if (endDate && recordDate > endDate) return false;
                }

                return true;
            });

         

          const filteredGeoJSON = { type:"FeatureCollection", features: filteredFeatures };
          geojsonLayer = L.geoJSON(filteredGeoJSON, {
              pointToLayer:(f,latlng)=>{
                  let color="red";
                  if(userLocation && userLocation.distanceTo(latlng)<=scale[radiusSlider.value]) color="green";
                  return L.circleMarker(latlng,{radius:8, fillColor:color, color:"#000", weight:1, opacity:1, fillOpacity:0.8});
              },
              onEachFeature:(f,layer)=>{
                  const p=f.properties;
                  // layer.bindPopup(`<strong>Consumer Name:</strong>${p.username || "Unknown"}<br><strong>Commodity Purchaed:</strong>${p.commodity || "Unknown"}<br>Purchase Date: </strong>${p.date? `<em>${new Date(p.date).toLocaleDateString('en-GB')}</em><br>`:""}Consumer Buying Price:</strong> ${p.buyingprice||'NA'}<br>Quantity Bought:</strong> ${p.quantitybought||'-'} ${p.unit||''}<br>`);
                  // Build table HTML
                  const table = `
                      <table style="border-collapse: collapse; width: 100%;">
                          
                          <tr>
                              <td style="border: 1px solid #999; padding: 4px;">Consumer Name</td>
                              <td style="border: 1px solid #999; padding: 4px;">${p.username || "Unknown"}</td>
                          </tr>
                          <tr>
                              <td style="border: 1px solid #999; padding: 4px;">Commodity Purchased</td>
                              <td style="border: 1px solid #999; padding: 4px;">${p.commodity || "Unknown"}</td>
                          </tr>
                          <tr>
                              <td style="border: 1px solid #999; padding: 4px;">Purchase Date</td>
                              <td style="border: 1px solid #999; padding: 4px;">${p.date ? new Date(p.date).toLocaleDateString('en-GB') : "-"}</td>
                          </tr>
                          <tr>
                              <td style="border: 1px solid #999; padding: 4px;">Buying Price</td>
                              <td style="border: 1px solid #999; padding: 4px;">${p.buyingprice || 'NA'}</td>
                          </tr>
                          <tr>
                              <td style="border: 1px solid #999; padding: 4px;">Quantity Bought</td>
                              <td style="border: 1px solid #999; padding: 4px;">${p.quantitybought || '-'} ${p.unit || ''}</td>
                          </tr>
                      </table>
                  `;

                  layer.bindPopup(table);
              }
          });
          markers.addLayer(geojsonLayer); map.addLayer(markers);

          if(zoomToBounds && (filteredFeatures.length>0 || userLocation)){
              let bounds = markers.getBounds();
              if(userLocation){ bounds.extend(userLocation); if(radiusCircle) bounds.extend(radiusCircle.getBounds()); }
              map.fitBounds(bounds,{padding:[30,30]});
          }
      }

      // --- Geolocation ---
      document.getElementById("locateBtn").addEventListener("click", ()=>{
        
          if(navigator.geolocation){
              navigator.geolocation.getCurrentPosition(pos=>{
                  userLocation = L.latLng(pos.coords.latitude,pos.coords.longitude);
                  if(userMarker) map.removeLayer(userMarker);
                  // üîµ Define a blue circle icon (SVG-based)
                  const blueIcon = L.divIcon({
                    html: '<div style="width:14px;height:14px;background-color:#007bff;border:2px solid white;border-radius:50%;box-shadow:0 0 3px rgba(0,0,0,0.5);"></div>',
                    className: '', // remove default marker styles
                    iconSize: [16, 16],
                    iconAnchor: [8, 8],
                  });

                  userMarker = L.marker(userLocation,{draggable:true,title:"My Location",icon: blueIcon}).addTo(map);
                  map.invalidateSize(); // ensures Leaflet recalculates map size
                  setTimeout(() => {
                    map.setView(userLocation, 14);
                  }, 100);
                  userMarker.on("dragend",e=>{ 
                      userLocation=e.target.getLatLng(); 
                      drawCircle(scale[radiusSlider.value]); 
                      updateStatsForRadius(); 
                      updateMarkers(commoditySelect.value,true); 
                  });
                  drawCircle(scale[radiusSlider.value]);
                  updateStatsForRadius();
                  updateMarkers(commoditySelect.value,true);
              });
          } else alert("Geolocation not supported by your browser.");
      });

      radiusSlider.addEventListener("input", function(){
        const meters = scale[radiusSlider.value];
        radiusValue.textContent =
        meters >= 1000 ? `${(meters / 1000).toLocaleString()} km` : `${meters} m`;


        //   radiusValue.textContent=this.value;
          if(userLocation){ 
              drawCircle(meters); 
              updateStatsForRadius(); 
              updateMarkers(commoditySelect.value,false); 
          }
      });

      // --- Fetch initial data ---
      // try {
      //       const res = await fetch("/api/consumers_geojson/", {
      //         credentials: "same-origin"
      //       });
      //       if (!res.ok) throw new Error("Failed to fetch GeoJSON");
      //       allData = await res.json();  // <-- FIXED
      //       updateStatsForRadius(); 
      //       updateMarkers(commoditySelect.value, true);
      //   } catch(err){
      //       console.error("Error loading GeoJSON:", err);
      //   }
      try {

          const token = sessionStorage.getItem("api_token");

          // ‚õî STOP if user is not logged in
          if (!token) {
              console.warn("User not logged in ‚Üí skipping API call");
              loginModal.style.display = "block";  // show login window
            return;
        }

        const res = await fetch("/api/consumers_geojson/", {
            credentials: "same-origin",
            headers: {
                "Authorization": `Bearer ${token}`
            }
        });

        if (!res.ok) throw new Error("Failed to fetch GeoJSON");

        allData = await res.json();

        updateStatsForRadius();
        updateMarkers(commoditySelect.value, true);

    } catch (err) {
        console.error("Error loading GeoJSON:", err);
    }


      commoditySelect.addEventListener("change", function(){
          selectedCommoditySpan.innerText=this.value;
          updateStatsForRadius();
          updateMarkers(this.value,true);
          
         
      });

         
        async function updateCommodityCount() {
          if (!allData || !Array.isArray(allData.features)) return;

          const selectedCommodity = commoditySelect.value.trim().toLowerCase();
          const startDate = document.getElementById("startDate").value;
          const endDate = document.getElementById("endDate").value;

          // --- Consumer count from map data ---
          const consumerCount = allData.features.filter(f => {
            const c = f.properties?.commodity?.trim().toLowerCase();
            const d = f.properties?.date;
            return (
              c === selectedCommodity &&
              (!startDate || d >= startDate) &&
              (!endDate || d <= endDate)
            );
          }).length;

          // --- Farmer count from API (fetch dynamically) ---
          let farmerCount = 0;
          try {
            const res = await fetch(`/api/farmers_prices/${encodeURIComponent(selectedCommodity)}/?start_date=${startDate}&end_date=${endDate}`);
            if (res.ok) {
              const farmerData = await res.json();
              farmerCount = farmerData.length || 0;
            } else {
              console.error("Farmer API error:", res.status);
            }
          } catch (err) {
            console.error("Error fetching farmer data:", err);
          }

          // --- Display combined info ---
          const totalText =
            consumerCount > 0 || farmerCount > 0
              ? `Consumer: ${consumerCount} records | Farmer: ${farmerCount} records`
              : "No records found";

          document.getElementById("commodityCount").innerText = totalText;
        }


        // Call initially and on change
        updateCommodityCount();
        commoditySelect.addEventListener("change", function(){
            selectedCommoditySpan.innerText=this.value;
            updateStatsForRadius();
            updateMarkers(this.value,true);
            updateCommodityCount();   // <-- added here
        });

      let districtLayer = null;

      const toggleDistrictBtn = document.getElementById("toggleDistrictBtn");
      let districtVisible = true;

       toggleDistrictBtn.addEventListener("click", () => {
          if(!districtLayer || !districtLayer.addTo) return; // safety check

          if(districtVisible){
              map.removeLayer(districtLayer);
              districtVisible = false;
              toggleDistrictBtn.innerText = "üó∫Ô∏è Show Districts";
          } else {
              districtLayer.addTo(map);
              districtVisible = true;
              toggleDistrictBtn.innerText = "üó∫Ô∏è Hide Districts";
          }
        });
      
        try {
              const districtResponse = await fetch("{% static 'districts_rev21june23.geojson' %}");
              const districtData = await districtResponse.json();
              
              districtLayer = L.geoJSON(districtData, {
                  style: { color: "#3388ff", weight: 2, fillOpacity: 0.1 }
              }).addTo(map); // initially visible
          } catch(err){
              console.error("Error loading district GeoJSON:", err);
          } 
        
       
      // --- Initial chart fetch ---
     
      document.getElementById('toggle-map-controls').addEventListener('click',()=>document.getElementById('map-controls').classList.toggle('collapsed'));

      function showTimeline(apmcName) {
        const url = `/apmc/${encodeURIComponent(apmcName)}/timeline-ajax/`;

        fetch(url)
            .then(res => res.text())
            .then(data => {
                const modalBody = document.querySelector('#apmcTimelineModal .modal-body');
                modalBody.innerHTML = data;

                // Show modal
                const modalEl = document.getElementById('apmcTimelineModal');
                const modal = new bootstrap.Modal(modalEl);
                modal.show();

                // Parse table rows
                const pricesRows = modalBody.querySelectorAll('tbody tr');
                const labels = [];
                const modalPrices = [];

                pricesRows.forEach(row => {
                    const date = row.cells[0].innerText;
                    const price = row.cells[6].innerText.replace(/,/g,'');
                    if(price){
                        labels.push(date);
                        modalPrices.push(parseFloat(price));
                    }
                });

                // Render chart after modal shown
                setTimeout(() => {
                    const ctx = modalBody.querySelector('#apmcTimelineChart').getContext('2d');

                    // Destroy previous chart only if it's a valid Chart instance
                    if(window.apmcTimelineChart instanceof Chart){
                        window.apmcTimelineChart.destroy();
                    }

                    window.apmcTimelineChart = new Chart(ctx, {
                        type: 'line',
                        data: {
                            labels: labels,
                            datasets: [{
                                label: 'Modal Price (‚Çπ/Quintal)',
                                data: modalPrices,
                                fill: false,
                                borderColor: 'rgba(75, 192, 192, 1)',
                                backgroundColor: 'rgba(75, 192, 192, 0.2)',
                                tension: 0.1
                            }]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            plugins: { legend: { position: 'top' }, title: { display: true, text: 'Modal Price Trend' } },
                            scales: {
                                x: { title: { display: true, text: 'Date' } },
                                y: { title: { display: true, text: 'Price (‚Çπ)' } }
                            }
                        }
                    });
                }, 200);

            })
            .catch(err => console.error(err));
    }

      // Attach event listener
      document.addEventListener('click', function(e){
        const target = e.target.closest('.apmc-link');
        if(target){
            e.preventDefault();
            const apmcName = target.dataset.apmc;
            showTimeline(apmcName);
        }
    });

   // Fetch Agmark Price and draw line chart
    let agmarkChart = null;
    let chartData = [];  // Store API response globally for tooltips
    let dateRangeSlider = document.getElementById('dateRangeSlider');
    let dateRangeLabel = document.getElementById('dateRangeLabel');

    document.getElementById("filterByDateBtn").addEventListener("click", async () => {
        const startDate = document.getElementById("startDate").value;
        const endDate = document.getElementById("endDate").value;
        const commodity = document.getElementById("commoditySelect").value;

        if (!commodity) return alert("Select a commodity first.");

        try {
            const url = `/api/webdata_prices/?commodity=${encodeURIComponent(commodity)}${startDate ? `&start_date=${startDate}` : ''}${endDate ? `&end_date=${endDate}` : ''}`;
            // const data = await fetch(url);
            const res = await fetch(url);
            const data = await res.json();

            if (data.error) {
                alert(data.error);
                return;
            }

            chartData = data;  // <-- Save globally for tooltip access

            // Extract labels and price arrays
            const labels = data.map(d =>{ 
                if(!d.date) return '';
                const dt = new Date(d.date);
                return dt.toLocaleDateString('en-GB');  // outputs DD/MM/YYYY
            });
            const minPrices = data.map(d => parseFloat(d.minprice));
            const maxPrices = data.map(d => parseFloat(d.maxprice));
            const modalPrices = data.map(d => parseFloat(d.modalprice));

            const ctx = document.getElementById("chartCanvas").getContext("2d");

            // Destroy previous chart
            if (agmarkChart instanceof Chart) agmarkChart.destroy();

            agmarkChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: labels,
                    datasets: [
                        { label: 'Min Price', data: minPrices, borderColor: 'green', tension: 0.3,borderWidth: 1, pointRadius: 2, pointHoverRadius: 8, pointBorderWidth: 1.5 },
                        { label: 'Max Price', data: maxPrices, borderColor: 'red', tension: 0.3,borderWidth: 1, pointRadius: 2, pointHoverRadius: 8, pointBorderWidth: 1.5},
                        { label: 'Modal Price', data: modalPrices, borderColor: 'blue', tension: 0.3,borderWidth: 1, pointRadius: 2, pointHoverRadius: 8, pointBorderWidth: 1.5}
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { position: 'top' },
                        title: { display: true, text: `${commodity} Price Trend per Qunital` },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    const price = context.raw;
                                    const datasetLabel = context.dataset.label;
                                    const index = context.dataIndex;
                                    const apmcName = chartData[index].apmc_name || "Unknown APMC";
                                    return `${datasetLabel}: ‚Çπ${price} (${apmcName})`;
                                }
                            }
                        },
                        zoom: {
                          zoom: {
                            wheel: {
                              enabled: true,     // ‚úÖ zoom with mouse wheel
                              // modifierKey: "ctrl" // optional: require Ctrl+scroll
                            },
                            pinch: {
                              enabled: true      // ‚úÖ zoom with pinch gesture
                            },
                            mode: "x",          // zoom both axes
                          },
                          pan: {
                            enabled: true,       // ‚úÖ allow dragging
                            mode: "x",
                          }
                        },
                      
                    },
                    scales: {
                        x: { title: { display: true, text: 'Date' } },
                        y: { title: { display: true, text: 'Price (‚Çπ)' } }
                    }
                }
            });
            const slider1 = document.getElementById('dateRangeSlider1');
const sliderStartLabel1 = document.getElementById('sliderStartLabel1');
const sliderEndLabel1 = document.getElementById('sliderEndLabel1');

// Destroy old slider if it exists (prevents duplicate sliders)
if (slider1.noUiSlider) {
    slider1.noUiSlider.destroy();
}

if (labels.length > 0) {
    // Create new slider instance
    noUiSlider.create(slider1, {
        start: [0, labels.length - 1],
        connect: true,
        range: { min: 0, max: labels.length - 1 },
        step: 1,
        behaviour: 'drag', // smoother dual handle drag
    });

    // Initialize date labels below slider
    sliderStartLabel1.textContent = labels[0];
    sliderEndLabel1.textContent = labels[labels.length - 1];

    // --- Debounce utility ---
    function debounce(fn, delay) {
        let timeout;
        return (...args) => {
            clearTimeout(timeout);
            timeout = setTimeout(() => fn(...args), delay);
        };
    }

    // --- Debounced chart update ---
    // --- Debounced chart update ---
      const updateChart1 = debounce((values) => {
        const startIndex1 = Math.floor(values[0]);
        const endIndex1 = Math.floor(values[1]);

        // Slice visible data
        const visibleLabels1 = labels.slice(startIndex1, endIndex1 + 1);
        const visibleMin = minPrices.slice(startIndex1, endIndex1 + 1);
        const visibleMax = maxPrices.slice(startIndex1, endIndex1 + 1);
        const visibleModal = modalPrices.slice(startIndex1, endIndex1 + 1);

        // Update chart datasets
        agmarkChart.data.labels = visibleLabels1;
        agmarkChart.data.datasets[0].data = visibleMin;
        agmarkChart.data.datasets[1].data = visibleMax;
        agmarkChart.data.datasets[2].data = visibleModal;

        agmarkChart.update('none'); // faster redraw
    }, 50);


    // --- Slider update handler ---
    slider1.noUiSlider.on('update', function (values) {
        const startIndex1 = Math.floor(values[0]);
        const endIndex1 = Math.floor(values[1]);

        sliderStartLabel1.textContent = labels[startIndex1];
        sliderEndLabel1.textContent = labels[endIndex1];

        updateChart1(values);
    });
}

                   
        
        } catch(err){
            console.error("Error fetching webdata prices:", err);
            alert("Please login to load Agmarknet prices.");
            if (!USER_LOGGED_IN) {
                const loginModal = document.getElementById("loginModal");

                if (loginModal) {
                    loginModal.style.display = "block";
                } else {
                    console.log("Modal not found in DOM");
                }
            }

        }
        // Refresh map markers to reflect selected date range
        updateMarkers(commoditySelect.value, true);
        await updateCommodityCount();
    });
     document.getElementById("filterByDateBtn").click();

 }//InitMap close
// --- Commodity count display ---
const token = sessionStorage.getItem("api_token");

const commoditySelect = document.getElementById("commoditySelect");
const commodityCount = document.getElementById("commodityCount");
const initialCommodity = commoditySelect?.value?.trim();

commoditySelect.addEventListener("change", () => {
// commoditySelect.addEventListener("change", async function () {
  const commodity = commoditySelect.value;
//   await updateAgmarkControls(commodity);

  if (!commodity) return;

  fetch(`/api/commodity_count/?commodity=${commodity}`, {
    headers: { "Authorization": `Bearer ${token}` } // if using JWT or session
  })
  .then(response => response.json())
  .then(data => {
    if (data.count !== undefined) {
      commodityCount.textContent = `${data.commodity}: ${data.count} records found`;
    } else {
      commodityCount.textContent = "Error fetching count.";
    }
  })
  .catch(err => {
    commodityCount.textContent = "Error connecting to server.";
    console.error(err);
  });
});
//  unified charts
let consumersChart = null;

async function fetchConsumersAndFarmersPrices() {
  const commodity = document.getElementById("commoditySelect").value;
  const startDate = document.getElementById("startDate").value;
  const endDate = document.getElementById("endDate").value;

  if (!commodity) return;

  try {
    // Fetch both datasets in parallel
    const [consumerRes, farmerRes] = await Promise.all([
      fetch(`/api/consumers1_prices/${encodeURIComponent(commodity)}/?${startDate ? `start_date=${startDate}&` : ""}${endDate ? `end_date=${endDate}` : ""}`),
      fetch(`/api/farmers_prices/${encodeURIComponent(commodity)}/?${startDate ? `start_date=${startDate}&` : ""}${endDate ? `end_date=${endDate}` : ""}`)
    ]);

    if (!consumerRes.ok || !farmerRes.ok) {
      console.error("Fetch error:", consumerRes.statusText, farmerRes.statusText);
      return;
    }

    const [consumerData, farmerData] = await Promise.all([
      consumerRes.json(),
      farmerRes.json()
    ]);

    // Sort and extract date/price
    const sortedConsumer = Array.isArray(consumerData)
      ? consumerData.sort((a, b) => new Date(a.date) - new Date(b.date))
      : [];

    const sortedFarmer = Array.isArray(farmerData)
      ? farmerData.sort((a, b) => new Date(a.date) - new Date(b.date))
      : [];

    const labels = [...new Set([...sortedConsumer, ...sortedFarmer].map(d => new Date(d.date).toLocaleDateString("en-GB")))];

    const consumerPrices = labels.map(label => {
      const found = sortedConsumer.find(d => new Date(d.date).toLocaleDateString("en-GB") === label);
      return found ? parseFloat(found.price) : null;
    });

    const farmerPrices = labels.map(label => {
      const found = sortedFarmer.find(d => new Date(d.date).toLocaleDateString("en-GB") === label);
      return found ? parseFloat(found.price) : null;
    });

    const ctx = document.getElementById("consumersChart").getContext("2d");

    if (consumersChart instanceof Chart) consumersChart.destroy();

    consumersChart = new Chart(ctx, {
      type: "line",
      data: {
        labels,
        datasets: [
          {
            label: "Consumer Buying Price (‚Çπ)",
            data: consumerPrices,
            borderColor: "rgba(54, 162, 235, 1)",       // blue
            backgroundColor: "rgba(54, 162, 235, 0.2)",
            borderWidth: 2,
            tension: 0.3,
          },
          {
            label: "Farmer's Selling Price (‚Çπ)",
            data: farmerPrices,
            borderColor: "rgba(75, 192, 75, 1)",        // green
            backgroundColor: "rgba(75, 192, 75, 0.2)",
            borderWidth: 2,
            tension: 0.3,
          },
        ],
      },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        plugins: {
          title: {
            display: true,
            text: `Consumer vs Farmer Prices for ${commodity}`,
          },
          legend: { position: "top" },
          tooltip: { mode: "index", intersect: false },
          zoom: {
            zoom: {
              wheel: {
                enabled: true,     // ‚úÖ zoom with mouse wheel
                // modifierKey: "ctrl" // optional: require Ctrl+scroll
              },
              pinch: {
                enabled: true      // ‚úÖ zoom with pinch gesture
              },
              mode: "xy",          // zoom both axes
            },
            pan: {
              enabled: true,       // ‚úÖ allow dragging
              mode: "xy",
            }
          }
        },
        
        scales: {
          x: { title: { display: true, text: "Date" } },
          y: { title: { display: true, text: "Price (‚Çπ)" } },
        },
      },
    });
   // ‚úÖ Initialize Dual-handle Date Slider (noUiSlider)
   const slider = document.getElementById('dateRangeSlider');
   const sliderStartLabel = document.getElementById('sliderStartLabel');
   const sliderEndLabel = document.getElementById('sliderEndLabel');

    // Destroy old slider if it exists (prevents duplicate sliders)
    if (slider.noUiSlider) {
        slider.noUiSlider.destroy();
    }

    if (labels.length > 0) {
        // Create new slider instance
        noUiSlider.create(slider, {
            start: [0, labels.length - 1],
            connect: true,
            range: { min: 0, max: labels.length - 1 },
            step: 1,
            behaviour: 'drag', // smoother dual handle drag
        });

        // Initialize date labels below slider
        sliderStartLabel.textContent = labels[0];
        sliderEndLabel.textContent = labels[labels.length - 1];

    // --- Debounce utility ---
    function debounce(fn, delay) {
        let timeout;
        return (...args) => {
            clearTimeout(timeout);
            timeout = setTimeout(() => fn(...args), delay);
        };
    }

    // --- Debounced chart update ---
    const updateChart = debounce((values) => {
        const startIndex = Math.floor(values[0]);
        const endIndex = Math.floor(values[1]);
        const visibleLabels = labels.slice(startIndex, endIndex + 1);

        consumersChart.options.scales.x.min = visibleLabels[0];
        consumersChart.options.scales.x.max = visibleLabels[visibleLabels.length - 1];
        consumersChart.update('none');
    }, 100); // updates every 100ms max

    // --- Slider update handler ---
    slider.noUiSlider.on('update', function (values) {
        // Update labels immediately
        const startIndex = Math.floor(values[0]);
        const endIndex = Math.floor(values[1]);
        sliderStartLabel.textContent = labels[startIndex];
        sliderEndLabel.textContent = labels[endIndex];

        // Trigger debounced chart update
        updateChart(values);
    });
}

  } catch (err) {
    console.error("Error fetching prices:", err);
  }
}

// Attach to filter & commodity change
document.getElementById("filterByDateBtn").addEventListener("click", fetchConsumersAndFarmersPrices);
document.getElementById("commoditySelect").addEventListener("change", fetchConsumersAndFarmersPrices);

// Initial load
fetchConsumersAndFarmersPrices();
//unifoed over

// Toggle Show/Hide for all trend charts
document.querySelectorAll('.toggle-chart-btn').forEach(btn => {
  btn.addEventListener('click', () => {
    const targetId = btn.dataset.target;
    const targetCanvas = document.getElementById(targetId);

    if (targetCanvas.style.display === 'none') {
      targetCanvas.style.display = 'block';
      btn.textContent = 'Hide';
    } else {
      targetCanvas.style.display = 'none';
      btn.textContent = 'Show';
    }
  });
});


let chartPopup = null;

document.getElementById("openAllChartsBtn").addEventListener("click", openAllChartsInPopup);

function openAllChartsInPopup() {
  const chartIds = ["consumersChart", "farmerChart", "chartCanvas"]; // all your chart <canvas> IDs
  const chartImages = chartIds.map(id => {
    const canvas = document.getElementById(id);
    return canvas ? canvas.toDataURL("image/png") : null;
  }).filter(Boolean);

  // Reuse popup if it‚Äôs already open
  if (!chartPopup || chartPopup.closed) {
    chartPopup = window.open("", "chartsPopup", "width=1100,height=900");
  } else {
    chartPopup.focus();
  }

  // Write content
  chartPopup.document.open();
  chartPopup.document.write(`
    <html>
      <head>
        <title>All Charts</title>
        <style>
          body {
            margin: 0;
            background: #f9fafb;
            font-family: Arial, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start;
            padding: 20px;
            gap: 20px;
          }
          img {
            max-width: 95%;
            border: 1px solid #ccc;
            border-radius: 8px;
            box-shadow: 0 0 10px rgba(0,0,0,0.1);
          }
          button {
            position: fixed;
            top: 10px;
            right: 10px;
            padding: 6px 12px;
            background: #007bff;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
          }
        </style>
      </head>
      <body>
        <button onclick="window.close()">Close</button>
        ${chartImages.map((src, i) => `<img src="${src}" alt="Chart ${i + 1}">`).join("")}
      </body>
    </html>
  `);
  chartPopup.document.close();
}
// const labels = agmarkChart.data.labels; // e.g. ['2024-01-01', '2024-01-02', ...]
if (window.agmarkChart && agmarkChart.data) {
  const labels = agmarkChart.data.labels;
  // rest of your code using agmarkChart
} else {
  console.warn("agmarkChart not ready yet.");
  return;
}

//DOM close
});
</script>
{% endblock %}