{% extends 'syncapp/base.html' %}
{% load static %}
{% load i18n %}
{% block title %}{% trans "Price Watch Dashboard" %}{% endblock %}

{% block extra_head %}
<script src="https://code.jquery.com/jquery-3.7.1.min.js"></script>
<script src="{% url 'javascript-catalog' %}"></script>


<link
  rel="stylesheet"
  href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
/>
<link
  rel="stylesheet"
  href="https://unpkg.com/leaflet.markercluster@1.5.3/dist/MarkerCluster.css"
/>
<link
  rel="stylesheet"
  href="https://unpkg.com/leaflet.markercluster@1.5.3/dist/MarkerCluster.Default.css"
/>
<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<script src="https://unpkg.com/leaflet.markercluster@1.5.3/dist/leaflet.markercluster.js"></script>
<link rel="stylesheet" href="{% static 'syncapp/css/map.css' %}">

<script src="https://cdn.jsdelivr.net/npm/chart.js@4.3.0/dist/chart.umd.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-zoom@2.0.1/dist/chartjs-plugin-zoom.min.js"></script>

<script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.4.1/papaparse.min.js"></script>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nouislider@15.7.0/dist/nouislider.min.css" />
<script src="https://cdn.jsdelivr.net/npm/nouislider@15.7.0/dist/nouislider.min.js"></script>

<link
  rel="stylesheet"
  href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css"
/>
<script src="https://cdn.jsdelivr.net/npm/sweetalert2@11"></script>

<link href="https://cdn.jsdelivr.net/npm/nouislider@15.7.0/dist/nouislider.min.css" rel="stylesheet">
<script src="https://cdn.jsdelivr.net/npm/nouislider@15.7.0/dist/nouislider.min.js"></script>

<style>
  main {
  display: block !important; /* disable flex for main */
}
  
  .resizable-chart {
    width: 100% !important;
    max-height: 300px;
    transition: max-height 0.3s ease;
  }

  .resizable-chart.expanded {
    max-height: 600px;
  }
  .toggle-chart-btn {
  font-size: 0.8rem;
  background-color: #f8f9fa;
  border: 1px solid #ccc;
  border-radius: 5px;
  padding: 2px 8px;
  margin-left: 10px;
  cursor: pointer;
  transition: background 0.2s ease;
}
.toggle-chart-btn:hover {
  background-color: #e2e6ea;
}
.chart-container {
  width: 100%;
  height: 300px;              /* default compact height */
  transition: height 0.28s ease;
  position: relative;
}

/* make the canvas fill the container */
.chart-container canvas {
  width: 100% !important;
  height: 100% !important;    /* Chart.js respects canvas height property */
  display: block;
}

/* expanded state */
.chart-container.expanded {
  height: 600px;              /* expanded height */
}
#dateRangeSlider {
  margin-top: 10px;
}
.noUi-handle {
  background-color: #007bff;
  border: 2px solid #0056b3;
  box-shadow: none;
}
.noUi-connect {
  background: #80bdff;
}

.chart-slider {
  width: 100%;
}
.noUi-target {
  background: #e9ecef;
  border-radius: 5px;
  height: 8px;
}
.noUi-handle {
  background: #007bff;
  border: none;
  box-shadow: 0 0 5px rgba(0,0,0,0.3);
  width: 16px;
  height: 16px;
  top: -4px;
}
.noUi-connect {
  background: #007bff;
}


#split-container {
  display: flex;
  width: 100%;
  height: calc(100vh - 120px);
  overflow: hidden;
}

#map-container {
  flex: 0 0 55%;
  min-width: 25%;
  transition: flex-basis 0.1s ease;
}

#divider {
  width: 6px;
  background: #ccc;
  cursor: col-resize;
  flex-shrink: 0;
}

#right-panel {
  flex: 0 0 45%;
  overflow-y: auto;
  background: #f9f9f9;
}
#map-container { outline: 1px dashed rgba(0,0,0,0.08); }
#right-panel { outline: 1px dashed rgba(0,0,0,0.08); }
#divider { outline: 1px solid rgba(0,0,0,0.06); }
</style>
{% endblock %}

{% block content %}
<!-- Login Modal -->
<div id="loginModal" style="display:block; position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.5); z-index:1000;">
  <div style="background:white; padding:20px; margin:100px auto; width:300px; border-radius:5px;">
    <h3>{% trans "Login" %}</h3>
    <form id="loginForm">
      <input type="text" id="username" placeholder="Username" required style="width:100%; margin-bottom:10px;">
      <input type="password" id="password" placeholder="Password" required style="width:100%; margin-bottom:10px;">
      <button type="submit" style="width:100%;">{% trans "Login" %}</button>
    </form>
    <div id="loginMessage" style="margin-top:10px; color:red;"></div>
  </div>
</div>
<!-- new filter panel-->


<!-- ====== TOP HORIZONTAL FILTER BAR ====== -->
<div id="filter-bar">
    
    <!-- Commodity -->
    <!-- <div class="fi"> -->
        <label><b>{% trans "Commodity" %}</b></label>
        <select id="commoditySelect">
            {% for type, items in grouped_commodities.items %}
            <optgroup label="{{ type }}">
                {% for item in items %}
                  <option value="{{ item.name }}"
                    {% if item.name == "Onion" %}selected{% endif %} 
                    {% if item.disabled %}disabled{% endif %}>
                    {{ item.label }}
                  </option>
                  {% endfor %}
              </optgroup>
              {% endfor %}
          </select>
      <!-- </div> -->

    <!-- Start Date -->
    <!-- <div class="fi"> -->
        <label>{% trans "Start Date" %}</label>
        <input type="date" id="startDate">
    <!-- </div> -->

    <!-- End Date -->
    <!-- <div class="fi"> -->
        <label>{% trans "End Date" %}</label>
        <input type="date" id="endDate">
    <!-- </div> -->

    <!-- Filter Button -->
    <!-- <div class="filter-btn"> -->
        <label>&nbsp;</label>
        <button id="filterByDateBtn" class="btn btn-primary btn-sm">{% trans "Filter" %}</button>
    <!-- </div> -->

    <!-- Radius Slider -->
    <div class="radius-container">
        <label>{% trans "Radius" %}: <span id="radiusValue">8 Km</span></label>
        <input type="range" id="radiusSlider" min="1" max="8" value="5" step="1">
    </div>
    <!-- Radius Stats -->
    <!-- <div class="stats-box" style="min-width: 200px;"> -->
        <!-- <label><b>Within Radius</b></label> -->
        <div id="radius-stats1" style="min-width: 200px;font-size: 0.85rem; line-height: 1.2; display:none;">
            <strong>{% trans "Stats Within Radius" %}:</strong><br>
            {% trans "Average Price" %}: <span id="avg-price-radius">--</span><br>
            <!-- Weighted: <span id="weighted-avg-radius">--</span><br> -->
            <!-- {% trans "Modal Price" %}: <span id="modal-price-radius">--</span> -->
        </div>
    <!-- </div> -->

    <!-- Location Button -->
    
        <label>&nbsp;</label>
        <button id="locateBtn" class="btn btn-light" style="border:1px solid #ccc;">
            <i class="fas fa-crosshairs"></i>{% trans "Locate Me" %}
        </button>
    
</div>
<!-- ====== FILTER BAR END ====== -->

<div id="split-container">
<div id="map-container">
 <div id="map"></div>
 <!-- <div id="filter-bar"> -->
  
  <!-- </div> -->
  <!-- <button id="toggle-map-controls">‚öôÔ∏è Hide/Show</button> -->
</div>
  <div id="divider"></div>
<div id="right-panel">
  <div class="box" id="graph-box">
    <!-- <h3>Charts for : 
      <span id="selected-commodity"></span>
    </h3> -->
    <div id="stats-container" style="display: flex; gap: 20px;">
      <div id="global-stats" style="margin-top: 4px;display:none;">
        <strong>All Consumers:</strong><br>
        Average Price: <span id="avg-price">--</span><br>
        Weighted Average: <span id="weighted-avg">--</span><br>
        Modal Price: <span id="modal-price">--</span>
      </div> 
      <div id="radius-stats1" style="margin-top: 4px;display:none;">
        <strong>Within Selected Radius:</strong><br>
        Average Price: <span id="avg-price-radius">--</span><br>
        Weighted Average: <span id="weighted-avg-radius">--</span><br>
        Modal Price: <span id="modal-price-radius">--</span>
      </div>
    </div> <!--# stats-container div close -->
    <!-- <hr> -->
    <div style="text-align: right; margin-bottom: 10px;">
      <button id="openAllChartsBtn" class="btn btn-primary">‚ÜóÔ∏è {% trans "Open Charts" %}</button>
    </div>
    
    
    <h3><b>{% trans "Consumer and Farmer Reported Price Trend" %} : 
      <span id="selected-commodity"></span></b>
      <span id="consumerapan"></span>
      <button class="toggle-chart-btn" data-target="consumersChart">{% trans "Hide Chart" %}</button>
      <!-- <button class="resize-chart-btn" data-target="consumersChart">Expand</button> -->
    </h3>
     
      <canvas id="consumersChart" class="resizable-chart"></canvas>
      <div class="chart-footer">
      <div class="chart-slider mt-3 px-3">
        <label for="dateRangeSlider" class="form-label fw-bold">{% trans "Adjust Date Range" %}</label>
        <div id="dateRangeSlider"></div>
        
        <div class="d-flex justify-content-between mt-2 text-muted small">
          <span id="sliderStartLabel">{% trans "Start Date" %}</span>
          <span id="sliderEndLabel">{% trans "End Date" %}</span>
        </div>
      </div>
      <br>
      <p class="chart-tip">üí° {% trans "Tip: Scroll to zoom, drag (or Ctrl + drag) to pan." %}</p>

      <hr>
     
    <h3><b>{% trans "AgmarkNet Price Trend" %} :
      <span id="selected-commodity"></span></b>
      <span id="agmarknet"></span>
      <button class="toggle-chart-btn" data-target="chartCanvas">{% trans "Hide Chart" %}</button>
      <!-- <button class="resize-chart-btn" data-target="chartCanvas">Expand</button> -->
    </h3>
    
     <div class="chart-x-slider-container">
      <canvas id="chartCanvas"></canvas>
      <div class="chart-footer1">
      <div class="chart-slider mt-3 px-3">
        <label for="dateRangeSlider" class="form-label fw-bold">{% trans "Adjust Date Range" %}</label>
        <div id="dateRangeSlider1"></div>
        
        <div class="d-flex justify-content-between mt-2 text-muted small">
          <span id="sliderStartLabel1">{% trans "Start Date" %}</span>
          <span id="sliderEndLabel1">{% trans "End Date" %}</span>
        </div>
      </div>
      <br>
      <p class="chart-tip">üí° {% trans "Tip: Scroll to zoom, drag (or Ctrl + drag) to pan." %}</p>
       <!-- Dual slider -->
      <div id="dateRangeSlider" style="margin: 20px auto; width: 90%;"></div>
      <div id="dateRangeLabel" style="text-align:center; margin-top: 6px; font-size: 0.9rem;"></div>
    </div>
  </div><!--# graph-box div close -->
</div><!--# <right>-panel div close -->
</div> <!--split container close-->
{% endblock %}

{% block extra_js %}
<script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns"></script>

<script>
const USER_LOGGED_IN = "{{ user.is_authenticated|yesno:'true,false' }}" === "true";
document.addEventListener("DOMContentLoaded", function() {
      
  // Wait until modal exists, then check login state
  const loginModal = document.getElementById("loginModal");
  const loginForm = document.getElementById("loginForm");
  const loginMessage = document.getElementById("loginMessage");

  // setTimeout(() => {
  //     locateUser();   // <-- place here
  // }, 100);

// RESIZE the map and left panel
const divider = document.getElementById("divider");
  const left = document.getElementById("map-container");
  const right = document.getElementById("right-panel");
  const container = document.getElementById("split-container");
  const map = document.getElementById("map");

  let isResizing = false;
  let startX = 0;
  let startLeftFlex = 0;

  divider.addEventListener("mousedown", (e) => {
    isResizing = true;
    startX = e.clientX;
    // calculate initial left flex percentage
    startLeftFlex = (left.offsetWidth / container.offsetWidth) * 100;
    document.body.style.cursor = "col-resize";
    document.body.style.userSelect = "none";
  });

  window.addEventListener("mousemove", (e) => {
    if (!isResizing) return;
    const dx = e.clientX - startX;
    const newLeftPercent = ((left.offsetWidth + dx) / container.offsetWidth) * 100;

    // clamp to reasonable limits (min 25%, max 75%)
    const clamped = Math.min(75, Math.max(25, newLeftPercent));
    left.style.flex = `0 0 ${clamped}%`;
    right.style.flex = `0 0 ${100 - clamped}%`;

    // refresh leaflet map dynamically if available
    if (window.myLeafletMap) {
      window.myLeafletMap.invalidateSize();
    }
  });

  window.addEventListener("mouseup", () => {
    isResizing = false;
    document.body.style.cursor = "default";
    document.body.style.userSelect = "auto";
  });

  // REsize over

  const endDateInput = document.getElementById("endDate");
  const startDateInput = document.getElementById("startDate");

  // helper: convert date to yyyy-mm-dd
  function toISO(d) {
    return d.toISOString().split("T")[0];
  }

  // helper: convert date to dd-mm-yyyy (for display or debug)
  function toDDMMYYYY(d) {
    return `${String(d.getDate()).padStart(2, "0")}-${String(d.getMonth() + 1).padStart(2, "0")}-${d.getFullYear()}`;
  }

  const today = new Date();
  const priorDate = new Date();
  priorDate.setDate(today.getDate() - 95);

  // ‚úÖ assign ISO values to date inputs
  endDateInput.value = toISO(today);
  startDateInput.value = toISO(priorDate);

  console.log("Start date (DD-MM-YYYY):", toDDMMYYYY(priorDate));
  console.log("End date (DD-MM-YYYY):", toDDMMYYYY(today));
  // üîπ Optional: automatically trigger data filter on load
  document.getElementById("filterByDateBtn").click();
    Chart.register(ChartZoom);

  

  const apmcCsvUrl = "{% static 'APMC_names.csv' %}";
  let apmcMarkers = L.layerGroup();  // Separate layer for APMC

//   const toggleApmcBtn = document.getElementById("toggleApmcBtn");
  let apmcVisible = false;

  const apmcIcon = L.icon({
    iconUrl: "{% static 'apmcM.png' %}",
    iconSize: [30, 30], // width, height
    iconAnchor: [15, 30], // point of the icon which will correspond to marker's location
    popupAnchor: [0, -30] // point from which the popup opens relative to the iconAnchor
  });

  
  // --------------------------
  // Token helpers 
  // --------------------------
  async function refreshToken(){
      const refresh = sessionStorage.getItem("refresh_token");
      if(!refresh) return false;
      try {
          const res = await fetch("/api/token/refresh/", {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({ refresh })
          });
          if(res.ok){
              const data = await res.json();
              sessionStorage.setItem("api_token", data.access);
              return true;
          } else {
              console.warn("Refresh token failed");
              return false;
          }
      } catch(err){
          console.error("Refresh token error:", err);
          return false;
      }
  }

  async function authFetch(url, options={}, retry=true){
    const token = sessionStorage.getItem("api_token");
    if(!token) throw new Error("No API token available");

    options.headers = {...options.headers,"Authorization":`Bearer ${token}`,"Content-Type":"application/json"};

    try {
        const res = await fetch(url, options);

        if(res.status === 401 && retry){
            const ok = await refreshToken();
            if(ok) return authFetch(url, options, false);
            else { 
                loginModal.style.display="block"; 
                throw new Error("Session expired, login required"); 
            }
        }

        if(res.status >= 400){ 
            try { return await res.json(); } catch(e){ return {}; }
        }

        return await res.json();

    } catch(err){
        console.error("authFetch error", err);
        return {}; 
    }
  }

  // --------------------------
  // Agrowon & Agmark fetch functions
  // --------------------------
    let agmarkChart = null;
    let agmarkData = [];

// --------------------------
  // Login form 
  // --------------------------
  loginForm.addEventListener("submit", async function (e) {
    e.preventDefault();
    const username = document.getElementById("username").value;
    const password = document.getElementById("password").value;

    try {
      const res = await fetch("/api/token/", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ username, password }),
      });
      const data = await res.json();
      if(data.access){
        if(!sessionStorage.getItem("api_token") && localStorage.getItem("api_token")){
            sessionStorage.setItem("api_token", localStorage.getItem("api_token"));
            sessionStorage.setItem("refresh_token", localStorage.getItem("refresh_token"));
            sessionStorage.setItem("username", localStorage.getItem("username"));
        } 
          localStorage.setItem("username", username);
          localStorage.setItem("api_token", data.access);
          localStorage.setItem("refresh_token", data.refresh);
          loginModal.style.display = "none";
          initMap();
          window._leaflet_map = map;
      } else {
          loginMessage.innerText = data.detail || "Login failed!";
      }
    } catch(err){
        console.error("Login error:", err);
        loginMessage.innerText = "Login failed! Check console.";
    }
  });

  // --------------------------
  // Auto-login check 
  // --------------------------
  (function syncTokens() {
    if (!sessionStorage.getItem("api_token") && localStorage.getItem("api_token")) {
        sessionStorage.setItem("api_token", localStorage.getItem("api_token"));
        sessionStorage.setItem("refresh_token", localStorage.getItem("refresh_token"));
        sessionStorage.setItem("username", localStorage.getItem("username"));
    }
})();
  (async function autoLoginCheck() {
    const token = sessionStorage.getItem("api_token");
    const refresh = sessionStorage.getItem("refresh_token");
    const username = sessionStorage.getItem("username");

    if(token) {
        // Try to use the token
        try {
            // Test a simple API endpoint to see if token is valid
            const res = await fetch("/api/consumers_geojson/", {
                headers: { "Authorization": `Bearer ${token}` }
            });
            if(res.ok){
                loginModal.style.display = "none";
                initMap();
                return;
            } 
        } catch(err){
            console.warn("Token check failed:", err);
        }
    }

    // Token invalid or missing, try refresh
    if(refresh){
        const ok = await refreshToken();
        if(ok){
            loginModal.style.display = "none";
            initMap();
            return;
        }
    }

    // No valid token or refresh -> show login modal
    loginModal.style.display = "block";
  })();



  // --------------------------
  // Map initialization
  // --------------------------
  async function initMap(){
      const commoditySelect = document.getElementById("commoditySelect");
      const selectedCommoditySpan = document.getElementById("selected-commodity");
      selectedCommoditySpan.textContent = gettext(commoditySelect.value);
      // selectedCommoditySpan.innerText = commoditySelect.value;

      const map = L.map('map',{ zoomControl: false }).setView([19.2, 73.0], 7);

      const osm = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { attribution: '&copy; OpenStreetMap' });
    //   const googleSat = L.tileLayer('https://mt1.google.com/vt/lyrs=s&x={x}&y={y}&z={z}', { attribution: '&copy; Google' });
      const googleSat= L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Street_Map/MapServer/tile/{z}/{y}/{x}', {
      attribution: '&copy; Esri, HERE, Garmin, ¬© OpenStreetMap contributors'
      });
     var googleHybrid = L.tileLayer(
        "https://mt1.google.com/vt/lyrs=y&x={x}&y={y}&z={z}",
        {
            maxZoom: 20,
            attribution: "&copy; Google"
        }
      ).addTo(map);
      googleHybrid.addTo(map);
      // osm.addTo(map);
      // const satelliteWithBoundaries = L.layerGroup([googleSat, googleSat1]);
      const baseMaps = { 
        "OpenStreetMap": osm, 
        "Google Satellite": googleHybrid 
      };
      const districtResponse = await fetch("{% static 'districts_rev21june23.geojson' %}");
      const districtData = await districtResponse.json();
      // const districtStyle = {
      //     color: "#3388ff",
      //     weight: 2,
      //     fillOpacity: 0.1
      // };

      // const districtLayer1 = L.geoJSON(districtData, { style: districtStyle });
      districtLayer1 = L.geoJSON(districtData, {
                  style: { color: "#3388ff", weight: 2, fillOpacity: 0.1 }
              });
      const overlayMaps = {
          "District Boundaries": districtLayer1
      };

    //   const baseMaps = { "OpenStreetMap": osm, "Google Satellite": googleSat };
      L.control.layers(baseMaps, overlayMaps, { position: 'topright' }).addTo(map);
      L.control.zoom({ position: 'topright' }).addTo(map);

      const markers = L.markerClusterGroup();
      let geojsonLayer = null;
      let allData = null;
      let userLocation = null;
      let userMarker = null;
      let radiusCircle = null;

      const radiusSlider = document.getElementById("radiusSlider");
      const radiusValue = document.getElementById("radiusValue");
      const scale = {
                    1: 100,
                    2: 500,
                    3: 1000,
                    4: 5000,
                    5: 8000,
                    6: 20000,
                    7: 100000,
                    8: 500000
        };
        
      function drawCircle(radius){
          if(!userLocation) return;
          if(radiusCircle) map.removeLayer(radiusCircle);
          radiusCircle = L.circle(userLocation, { radius: radius, color:"red", fillOpacity:0.05 }).addTo(map);
      }

      function computeStats(features, center=null, radius=null){
          let filtered = features;
          if(center && radius){
              filtered = features.filter(f=>{
                  const latlng = L.latLng(f.geometry.coordinates[1], f.geometry.coordinates[0]);
                  return center.distanceTo(latlng)<=radius;
              });
          }
          if(filtered.length === 0) return {avg:null, weighted:null, modal:null};
          const prices = filtered.map(f=>f.properties.buyingprice).filter(v=>v!==null);
          const unit = filtered.map(f => f.properties.unit).find(u => u !== null && u !== undefined) || '';
          const quantities = filtered.map(f=>f.properties.quantitybought).map(q=>q||1);
          const avg = prices.reduce((a,b)=>a+b,0)/prices.length;
          const weighted = prices.reduce((sum,p,i)=>sum+p*quantities[i],0)/quantities.reduce((a,b)=>a+b,0);
          const freq={}; prices.forEach(p=>freq[p]=(freq[p]||0)+1);
          let modal=prices[0], maxCount=0;
          for(const k in freq){ if(freq[k]>maxCount){ modal=k; maxCount=freq[k]; } }
          return {avg, weighted, modal};
      }

      function showGlobalStats(stats){
          document.getElementById("avg-price").innerText = stats.avg!==null ?` ‚Çπ${stats.avg.toFixed(2)} / ${stats.unit || ''}`: "No data";
          document.getElementById("weighted-avg").innerText = stats.weighted!==null ? stats.weighted.toFixed(2) : "No data";
          document.getElementById("modal-price").innerText = stats.modal!==null ? `‚Çπ${stats.modal}` : "No data";
      }

      function showRadiusStats(stats){
          document.getElementById("avg-price-radius").innerText = stats.avg!==null ?` ‚Çπ${stats.avg.toFixed(2)}  ${stats.unit || ''}`: "No data";
          document.getElementById("weighted-avg-radius").innerText = stats.weighted!==null ? stats.weighted.toFixed(2) : "No data";
          document.getElementById("modal-price-radius").innerText = stats.modal!==null ?`‚Çπ${stats.modal} ${stats.unit || ''}` : "No data";

          document.getElementById("radius-stats1").style.display = "block";
      }

      function updateStatsForRadius(){
        if(!allData || !Array.isArray(allData.features)) return;
        const commodity = commoditySelect.value.toLowerCase();
        const filtered = allData.features.filter(f => f.properties?.commodity?.toLowerCase() === commodity);
        showGlobalStats(computeStats(filtered));
        if(userLocation) showRadiusStats(computeStats(filtered, userLocation, scale[radiusSlider.value]));
        else showRadiusStats({avg:null, weighted:null, modal:null});
      }

      function updateMarkers(commodity, zoomToBounds=false){
          markers.clearLayers();
          if(geojsonLayer) map.removeLayer(geojsonLayer);
          if(!allData || !Array.isArray(allData.features)) return;

          const indiaBounds = L.latLngBounds([6.5,68.0],[35.5,97.5]);

// // Filter Map based on date range added
            const startDateInput = document.getElementById("startDate").value;
            const endDateInput = document.getElementById("endDate").value;
            const startDate = startDateInput ? new Date(startDateInput) : null;
            const endDate = endDateInput ? new Date(endDateInput) : null;

            const filteredFeatures = allData.features.filter(f => {
                const latlng = L.latLng(f.geometry.coordinates[1], f.geometry.coordinates[0]);
                const dbName = f.properties.commodity?.trim().toLowerCase();
                const selected = commodity.trim().toLowerCase();

                // Skip if location not in India bounds or commodity mismatch
                if (!indiaBounds.contains(latlng) || dbName !== selected) return false;

                // Filter by date range if available
                if (f.properties.date) {
                    const recordDate = new Date(f.properties.date);
                    if (startDate && recordDate < startDate) return false;
                    if (endDate && recordDate > endDate) return false;
                }

                return true;
            });

         

          const filteredGeoJSON = { type:"FeatureCollection", features: filteredFeatures };
          // geojsonLayer = L.geoJSON(filteredGeoJSON, {
          //     pointToLayer:(f,latlng)=>{
          //         let color="red";
          //         if(userLocation && userLocation.distanceTo(latlng)<=scale[radiusSlider.value]) color="green";
          //         return L.circleMarker(latlng,{radius:8, fillColor:color, color:"#000", weight:1, opacity:1, fillOpacity:0.8});
          //     },
          //     onEachFeature:(f,layer)=>{
          //         const p=f.properties;
          //         // layer.bindPopup(`<strong>Consumer Name:</strong>${p.username || "Unknown"}<br><strong>Commodity Purchaed:</strong>${p.commodity || "Unknown"}<br>Purchase Date: </strong>${p.date? `<em>${new Date(p.date).toLocaleDateString('en-GB')}</em><br>`:""}Consumer Buying Price:</strong> ${p.buyingprice||'NA'}<br>Quantity Bought:</strong> ${p.quantitybought||'-'} ${p.unit||''}<br>`);
          //         // Build table HTML
          //         const table = `
          //             <table style="border-collapse: collapse; width: 100%;">
                          
          //                 <tr>
          //                     <td style="border: 1px solid #999; padding: 4px;">Consumer Name</td>
          //                     <td style="border: 1px solid #999; padding: 4px;">${p.username || "Unknown"}</td>
          //                 </tr>
          //                 <tr>
          //                     <td style="border: 1px solid #999; padding: 4px;">Commodity Purchased</td>
          //                     <td style="border: 1px solid #999; padding: 4px;">${p.commodity || "Unknown"}</td>
          //                 </tr>
          //                 <tr>
          //                     <td style="border: 1px solid #999; padding: 4px;">Purchase Date</td>
          //                     <td style="border: 1px solid #999; padding: 4px;">${p.date ? new Date(p.date).toLocaleDateString('en-GB') : "-"}</td>
          //                 </tr>
          //                 <tr>
          //                     <td style="border: 1px solid #999; padding: 4px;">Buying Price</td>
          //                     <td style="border: 1px solid #999; padding: 4px;">${p.buyingprice || 'NA'}</td>
          //                 </tr>
          //                 <tr>
          //                     <td style="border: 1px solid #999; padding: 4px;">Quantity Bought</td>
          //                     <td style="border: 1px solid #999; padding: 4px;">${p.quantitybought || '-'} ${p.unit || ''}</td>
          //                 </tr>
          //             </table>
          //         `;

          //         layer.bindPopup(table);
          //     }
          // });
          // markers.addLayer(geojsonLayer); map.addLayer(markers);
            filteredFeatures.forEach(f => {
                const lat = f.geometry.coordinates[1];
                const lon = f.geometry.coordinates[0];

                const marker = L.circleMarker([lat, lon], {
                    radius: 7,
                    color: "#000",
                    weight: 1,
                    fillOpacity: 0.8,
                    fillColor: (
                        userLocation &&
                        userLocation.distanceTo([lat, lon]) <= scale[radiusSlider.value]
                    ) ? "green" : "red"
                });

                // üîë attach full feature to marker
                marker.featureData = f;

                // keep your existing popup
                const p = f.properties;
                marker.bindPopup(`
                    <table style="border-collapse: collapse; width: 100%;">
                      <tr><td>Consumer</td><td>${p.username || "Unknown"}</td></tr>
                      <tr><td>Commodity</td><td>${p.commodity}</td></tr>
                      <tr><td>Date</td><td>${p.date ? new Date(p.date).toLocaleDateString('en-GB') : "-"}</td></tr>
                      <tr><td>Price</td><td>${p.buyingprice || "NA"}</td></tr>
                      <tr><td>Qty</td><td>${p.quantitybought || "-"} ${p.unit || ""}</td></tr>
                    </table>
                `);

                markers.addLayer(marker);
            });

            map.addLayer(markers);
            markers.on("clusterclick", function (e) {
                L.DomEvent.stop(e);   // ‚õî prevent zoom

                const rows = e.layer
                    .getAllChildMarkers()
                    .map(m => m.featureData)
                    .filter(f => f?.properties?.date && f?.properties?.buyingprice != null);
                // ‚úÖ APPLY DATE + RADIUS FILTER
                rows = filterRowsForChart(rows);
                rows.sort(
                    (a, b) =>
                        new Date(a.properties.date) -
                        new Date(b.properties.date)
                );

                if (rows.length < 2) {
                    alert("Not enough data for time series");
                    return;
                }

                rows.sort(
                    (a, b) =>
                        new Date(a.properties.date) -
                        new Date(b.properties.date)
                );

                openClusterTimeline(e.latlng, rows);
            });
            function openClusterTimeline(latlng, rows) {
                const id = "chart-" + Date.now();
                const radiusText = userLocation
                    ? `Radius: ${(scale[radiusSlider.value] / 1000).toFixed(1)} km`
                    : "Radius: All";

                const dateText =
                    `${startDateInput || "Any"} ‚Üí ${endDateInput || "Any"}`;

                const html = `
                  <div style="font-size:12px;margin-bottom:4px">
                    ${radiusText}<br>
                    Date: ${dateText}
                  </div>
                  <div style="width:360px;height:220px">
                    <canvas id="${id}"></canvas>
                  </div>
                `;


                L.popup({ maxWidth: 400 })
                    .setLatLng(latlng)
                    .setContent(html)
                    .openOn(map);

                setTimeout(() => {
                    const ctx = document.getElementById(id).getContext("2d");

                    new Chart(ctx, {
                        type: "line",
                        data: {
                            labels: rows.map(r => {
                            const d = new Date(r.properties.date);
                            return d.toLocaleString("en-GB", {
                                day: "2-digit",
                                month: "2-digit",
                                year: "numeric",
                                hour: "2-digit",
                                minute: "2-digit"
                            });
                        }),

                            datasets: [{
                                label: "Price",
                                data: rows.map(r => r.properties.buyingprice),
                                tension: 0.3,
                                borderWidth: 2,
                                pointRadius: 3
                            }]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            scales: {
                                x: { title: { display: true, text: "Date" } },
                                y: { title: { display: true, text: "Price (‚Çπ)" } }
                            }
                        }
                    });
                }, 150);
            }


          if(zoomToBounds && (filteredFeatures.length>0 || userLocation)){
              let bounds = markers.getBounds();
              if(userLocation){ bounds.extend(userLocation); if(radiusCircle) bounds.extend(radiusCircle.getBounds()); }
              map.fitBounds(bounds,{padding:[30,30]});
          }
      }

      // --- Geolocation ---
      document.getElementById("locateBtn").addEventListener("click", locateUser);

        function locateUser() {
          if(navigator.geolocation){
              navigator.geolocation.getCurrentPosition(pos=>{
                  userLocation = L.latLng(pos.coords.latitude,pos.coords.longitude);
                  if(userMarker) map.removeLayer(userMarker);
                  // üîµ Define a blue circle icon (SVG-based)
                  const blueIcon = L.divIcon({
                    html: '<div style="width:18px;height:18px;background-color:#00aaff;;border:3px solid white;border-radius:50%;box-shadow:0 0 8px rgba(0,0,0,0.9);"></div>',
                    className: '', // remove default marker styles
                    iconSize: [18, 18],
                    iconAnchor: [9, 9],
                  });

                  userMarker = L.marker(userLocation,{draggable:true,title:"My Location",icon: blueIcon}).addTo(map);
                  map.invalidateSize(); // ensures Leaflet recalculates map size
                  setTimeout(() => {
                    
                    map.setView(userLocation, 16);
                  }, 100);
                  userMarker.on("dragend",e=>{ 
                      userLocation=e.target.getLatLng(); 
                      drawCircle(scale[radiusSlider.value]); 
                      updateStatsForRadius(); 
                      updateMarkers(commoditySelect.value,true); 
                  });
                  drawCircle(scale[radiusSlider.value]);
                  updateStatsForRadius();
                  updateMarkers(commoditySelect.value,true);
              });
          } else alert("Geolocation not supported by your browser.");
        }
      

      radiusSlider.addEventListener("input", function(){
        const meters = scale[radiusSlider.value];
        radiusValue.textContent =
        meters >= 1000 ? `${(meters / 1000).toLocaleString()} km` : `${meters} m`;


        //   radiusValue.textContent=this.value;
          if(userLocation){ 
              drawCircle(meters); 
              updateStatsForRadius(); 
              updateMarkers(commoditySelect.value,false); 
          }
      });
      locateUser();
      // --- Fetch initial data ---
      // try {
      //       const res = await fetch("/api/consumers_geojson/", {
      //         credentials: "same-origin"
      //       });
      //       if (!res.ok) throw new Error("Failed to fetch GeoJSON");
      //       allData = await res.json();  // <-- FIXED
      //       updateStatsForRadius(); 
      //       updateMarkers(commoditySelect.value, true);
      //   } catch(err){
      //       console.error("Error loading GeoJSON:", err);
      //   }
      try {

          const token = sessionStorage.getItem("api_token");

          // ‚õî STOP if user is not logged in
          if (!token) {
              console.warn("User not logged in ‚Üí skipping API call");
              loginModal.style.display = "block";  // show login window
            return;
        }

        const res = await fetch("/api/consumers_geojson/", {
            credentials: "same-origin",
            headers: {
                "Authorization": `Bearer ${token}`
            }
        });

        if (!res.ok) throw new Error("Failed to fetch GeoJSON");

        allData = await res.json();

        updateStatsForRadius();
        updateMarkers(commoditySelect.value, true);

    } catch (err) {
        console.error("Error loading GeoJSON:", err);
    }


      commoditySelect.addEventListener("change", function(){
          selectedCommoditySpan.innerText=this.value;
          updateStatsForRadius();
          updateMarkers(this.value,true);
          
         
      });

         
        async function updateCommodityCount() {
          if (!allData || !Array.isArray(allData.features)) return;

          const selectedCommodity = commoditySelect.value.trim().toLowerCase();
          const startDate = document.getElementById("startDate").value;
          const endDate = document.getElementById("endDate").value;

          // --- Consumer count from map data ---
          const consumerCount = allData.features.filter(f => {
            const c = f.properties?.commodity?.trim().toLowerCase();
            const d = f.properties?.date;
            return (
              c === selectedCommodity &&
              (!startDate || d >= startDate) &&
              (!endDate || d <= endDate)
            );
          }).length;

          // --- Farmer count from API (fetch dynamically) ---
          let farmerCount = 0;
          try {
            const res = await fetch(`/api/farmers_prices/${encodeURIComponent(selectedCommodity)}/?start_date=${startDate}&end_date=${endDate}`);
            if (res.ok) {
              const farmerData = await res.json();
              farmerCount = farmerData.length || 0;
            } else {
              console.error("Farmer API error:", res.status);
            }
          } catch (err) {
            console.error("Error fetching farmer data:", err);
          }

          // --- Display combined info ---
          const totalText =
            consumerCount > 0 || farmerCount > 0
              ? `Consumer: ${consumerCount} records | Farmer: ${farmerCount} records`
              : "No records found";

          // document.getElementById("commodityCount").innerText = totalText;
        }


        // Call initially and on change
        updateCommodityCount();
        commoditySelect.addEventListener("change", function(){
            selectedCommoditySpan.innerText=this.value;
            updateStatsForRadius();
            updateMarkers(this.value,true);
            updateCommodityCount();   // <-- added here
        });

      let districtLayer = null;

      // const toggleDistrictBtn = document.getElementById("toggleDistrictBtn");
      // let districtVisible = true;

      //  toggleDistrictBtn.addEventListener("click", () => {
      //     if(!districtLayer || !districtLayer.addTo) return; // safety check

      //     if(districtVisible){
      //         map.removeLayer(districtLayer);
      //         districtVisible = false;
      //         toggleDistrictBtn.innerText = "üó∫Ô∏è Show Districts";
      //     } else {
      //         districtLayer.addTo(map);
      //         districtVisible = true;
      //         toggleDistrictBtn.innerText = "üó∫Ô∏è Hide Districts";
      //     }
      //   });
      
      //   try {
      //         const districtResponse = await fetch("{% static 'districts_rev21june23.geojson' %}");
      //         const districtData = await districtResponse.json();
              
      //         // districtLayer = L.geoJSON(districtData, {
      //         //     style: { color: "#3388ff", weight: 2, fillOpacity: 0.1 }
      //         // }).addTo(map); // initially visible
      //     } catch(err){
      //         console.error("Error loading district GeoJSON:", err);
      //     } 
        
       
      // --- Initial chart fetch ---
     
      // document.getElementById('toggle-map-controls').addEventListener('click',()=>document.getElementById('map-controls').classList.toggle('collapsed'));

      function showTimeline(apmcName) {
        const url = `/apmc/${encodeURIComponent(apmcName)}/timeline-ajax/`;

        fetch(url)
            .then(res => res.text())
            .then(data => {
                const modalBody = document.querySelector('#apmcTimelineModal .modal-body');
                modalBody.innerHTML = data;

                // Show modal
                const modalEl = document.getElementById('apmcTimelineModal');
                const modal = new bootstrap.Modal(modalEl);
                modal.show();

                // Parse table rows
                const pricesRows = modalBody.querySelectorAll('tbody tr');
                const labels = [];
                const modalPrices = [];

                pricesRows.forEach(row => {
                    const date = row.cells[0].innerText;
                    const price = row.cells[6].innerText.replace(/,/g,'');
                    if(price){
                        labels.push(date);
                        modalPrices.push(parseFloat(price));
                    }
                });

                // Render chart after modal shown
                setTimeout(() => {
                    const ctx = modalBody.querySelector('#apmcTimelineChart').getContext('2d');

                    // Destroy previous chart only if it's a valid Chart instance
                    if(window.apmcTimelineChart instanceof Chart){
                        window.apmcTimelineChart.destroy();
                    }
                    const minLabel = gettext("Min");
                    const modalLabel = gettext("Modal");
                    const maxLabel = gettext("Max");
                    window.apmcTimelineChart = new Chart(ctx, {
                        type: 'line',
                        data: {
                            labels: labels,
                            datasets: [{
                                label: modalLabel,
                                data: modalPrices,
                                fill: false,
                                borderColor: 'rgba(75, 192, 192, 1)',
                                backgroundColor: 'rgba(75, 192, 192, 0.2)',
                                tension: 0.1
                            }]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            plugins: { legend: { position: 'top' }, title: { display: true, text: 'Modal Price Trend' } },
                            scales: {
                                x: { title: { display: true, text: 'Date' } },
                                y: { title: { display: true, text: 'Price (‚Çπ)' } }
                            }
                        }
                    });
                }, 200);

            })
            .catch(err => console.error(err));
    }

      // Attach event listener
      document.addEventListener('click', function(e){
        const target = e.target.closest('.apmc-link');
        if(target){
            e.preventDefault();
            const apmcName = target.dataset.apmc;
            showTimeline(apmcName);
        }
    });

   // Fetch Agmark Price and draw line chart
    let agmarkChart = null;
    let chartData = [];  // Store API response globally for tooltips
    let dateRangeSlider = document.getElementById('dateRangeSlider');
    let dateRangeLabel = document.getElementById('dateRangeLabel');

    document.getElementById("filterByDateBtn").addEventListener("click", async () => {
        const startDate = document.getElementById("startDate").value;
        const endDate = document.getElementById("endDate").value;
        const commodity = document.getElementById("commoditySelect").value;

        if (!commodity) return alert("Select a commodity first.");

        try {
            const url = `/api/webdata_prices/?commodity=${encodeURIComponent(commodity)}${startDate ? `&start_date=${startDate}` : ''}${endDate ? `&end_date=${endDate}` : ''}`;
            // const data = await fetch(url);
            const res = await fetch(url);
            const data = await res.json();
            // alert(commodity)

            if (data.error) {
                alert(data.error);
                return;
            }

            chartData = data;  // <-- Save globally for tooltip access

            // Extract labels and price arrays
            const labels = data.map(d =>{ 
                if(!d.date) return '';
                const dt = new Date(d.date);
                return dt.toLocaleDateString('en-GB');  // outputs DD/MM/YYYY
            });
            const minPrices = data.map(d => parseFloat(d.minprice));
            const maxPrices = data.map(d => parseFloat(d.maxprice));
            const modalPrices = data.map(d => parseFloat(d.modalprice));

            const ctx = document.getElementById("chartCanvas").getContext("2d");

            // Destroy previous chart
            if (agmarkChart instanceof Chart) agmarkChart.destroy();

            agmarkChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: labels,
                    datasets: [
                        { label: gettext('Min Price'), data: minPrices, borderColor: 'green', tension: 0.3,borderWidth: 1, pointRadius: 0, pointHoverRadius: 0,pointHitRadius: 12, },
                        { label: gettext('Max Price'), data: maxPrices, borderColor: 'red', tension: 0.3,borderWidth: 1, pointRadius: 0, pointHoverRadius: 0,pointHitRadius: 12,},
                        { label: gettext('Modal Price'), data: modalPrices, borderColor: 'blue', tension: 0.3,borderWidth: 1, pointRadius: 0, pointHoverRadius: 0,pointHitRadius: 12,}
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { position: 'top' },
                        title: { display: true, 
                        // text: `${commodity} Price Trend per Qunital` },
                        text: `${gettext(commodity)} ${gettext("Price Trend per Quintal")}`},
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    const price = context.raw;
                                    const datasetLabel = context.dataset.label;
                                    const index = context.dataIndex;
                                    const apmcName = chartData[index].apmc_name || "Unknown APMC";
                                    return `${datasetLabel}: ‚Çπ${price} (${apmcName})`;
                                }
                            }
                        },
                        zoom: {
                          zoom: {
                            wheel: {
                              enabled: true,     // ‚úÖ zoom with mouse wheel
                              // modifierKey: "ctrl" // optional: require Ctrl+scroll
                            },
                            pinch: {
                              enabled: true      // ‚úÖ zoom with pinch gesture
                            },
                            mode: "x",          // zoom both axes
                          },
                          pan: {
                            enabled: true,       // ‚úÖ allow dragging
                            mode: "x",
                          }
                        },
                      
                    },
                    scales: {
                        x: { title: { display: true, text: 'Date' } },
                        y: { title: { display: true, text: 'Price (‚Çπ)' } }
                    }
                }
            });
            const slider1 = document.getElementById('dateRangeSlider1');
const sliderStartLabel1 = document.getElementById('sliderStartLabel1');
const sliderEndLabel1 = document.getElementById('sliderEndLabel1');

// Destroy old slider if it exists (prevents duplicate sliders)
if (slider1.noUiSlider) {
    slider1.noUiSlider.destroy();
}

if (labels.length > 0) {
    // Create new slider instance
    noUiSlider.create(slider1, {
        start: [0, labels.length - 1],
        connect: true,
        range: { min: 0, max: labels.length - 1 },
        step: 1,
        behaviour: 'drag', // smoother dual handle drag
    });

    // Initialize date labels below slider
    sliderStartLabel1.textContent = labels[0];
    sliderEndLabel1.textContent = labels[labels.length - 1];

    // --- Debounce utility ---
    function debounce(fn, delay) {
        let timeout;
        return (...args) => {
            clearTimeout(timeout);
            timeout = setTimeout(() => fn(...args), delay);
        };
    }

    // --- Debounced chart update ---
    // --- Debounced chart update ---
      const updateChart1 = debounce((values) => {
        const startIndex1 = Math.floor(values[0]);
        const endIndex1 = Math.floor(values[1]);

        // Slice visible data
        const visibleLabels1 = labels.slice(startIndex1, endIndex1 + 1);
        const visibleMin = minPrices.slice(startIndex1, endIndex1 + 1);
        const visibleMax = maxPrices.slice(startIndex1, endIndex1 + 1);
        const visibleModal = modalPrices.slice(startIndex1, endIndex1 + 1);

        // Update chart datasets
        agmarkChart.data.labels = visibleLabels1;
        agmarkChart.data.datasets[0].data = visibleMin;
        agmarkChart.data.datasets[1].data = visibleMax;
        agmarkChart.data.datasets[2].data = visibleModal;

        agmarkChart.update('none'); // faster redraw
    }, 50);


    // --- Slider update handler ---
    slider1.noUiSlider.on('update', function (values) {
        const startIndex1 = Math.floor(values[0]);
        const endIndex1 = Math.floor(values[1]);

        sliderStartLabel1.textContent = labels[startIndex1];
        sliderEndLabel1.textContent = labels[endIndex1];

        updateChart1(values);
    });
}

                   
        
        } catch(err){
            console.error("Error fetching webdata prices:", err);
            alert("Please login to load Agmarknet prices.");
            if (!USER_LOGGED_IN) {
                const loginModal = document.getElementById("loginModal");

                if (loginModal) {
                    loginModal.style.display = "block";
                } else {
                    console.log("Modal not found in DOM");
                }
            }

        }
        // Refresh map markers to reflect selected date range
        updateMarkers(commoditySelect.value, true);
        await updateCommodityCount();
    });
     document.getElementById("filterByDateBtn").click();

 }//InitMap close
// --- Commodity count display ---
const token = sessionStorage.getItem("api_token");

const commoditySelect = document.getElementById("commoditySelect");
const commodityCount = document.getElementById("commodityCount");
const initialCommodity = commoditySelect?.value?.trim();

commoditySelect.addEventListener("change", () => {
  
// commoditySelect.addEventListener("change", async function () {
  const commodity = commoditySelect.value;
//   await updateAgmarkControls(commodity);

  if (!commodity) return;

  fetch(`/api/commodity_count/?commodity=${commodity}`, {
    headers: { "Authorization": `Bearer ${token}` } // if using JWT or session
  })
  .then(response => response.json())
  .then(data => {
    if (data.count !== undefined) {
      commodityCount.textContent = `${data.commodity}: ${data.count} records found`;
    } else {
      commodityCount.textContent = "Error fetching count.";
    }
  })
  .catch(err => {
    commodityCount.textContent = "Error connecting to server.";
    console.error(err);
  });
});
//  unified charts
let consumersChart = null;

/* ---------------------------------------
   Plugin: Draw separate c/f counts under x-axis
---------------------------------------- */
const pointCountPlugin = {
    id: 'pointCountPlugin',
    afterDatasetsDraw(chart, args, options) {
        const { ctx } = chart;
        const counts = options.counts || {};

        // Get all unique dates from all datasets
        const allDates = chart.data.datasets
            .flatMap(ds => ds.data.map(d => d.x.toISOString().split("T")[0]));
        const uniqueDates = [...new Set(allDates)];

        uniqueDates.forEach(dateKey => {
            // For each dataset
            chart.data.datasets.forEach((dataset, datasetIndex) => {
                const entry = counts[dateKey] || { c: 0, f: 0 };
                const nValue = datasetIndex === 0 ? entry.c : entry.f;

                // Find the first point in this dataset matching the date
                const point = dataset.data.find(d => d.x.toISOString().split("T")[0] === dateKey);
                if (!point) return;

                const meta = chart.getDatasetMeta(datasetIndex);
                // const chartPoint = meta.data.find(p => p.x === chart.scales.x.getPixelForValue(point.x));
                
                // const x = chart.scales.x.getPixelForValue(point.x);
                // const y = chartPoint ? chartPoint.y + (datasetIndex === 0 ? 20 : 36) : 0;
                // get correct X,Y directly from meta for this point index
              const pointIndex = dataset.data.indexOf(point);
              if (pointIndex === -1) return;

              const chartPoint = meta.data[pointIndex];
              if (!chartPoint) return;

              const x = chartPoint.x;
              const y = chartPoint.y + (datasetIndex === 0 ? 20 : 36);


                ctx.save();
                ctx.font = "12px sans-serif";
                ctx.textAlign = "center";
                ctx.fillStyle = dataset.borderColor || "black";
                ctx.fillText(`n=${nValue}`, x, y);
                ctx.restore();
            });
        });
    }
};


const nCountPlugin = {
    id: "nCountPlugin",
    afterLayout(chart, args, options) {
        const { ctx, scales: { x } } = chart;
        const counts = options.counts || {};
        if (!x) return; // x scale not ready

        ctx.save();
        ctx.font = "12px sans-serif";
        ctx.textAlign = "center";

        Object.keys(counts).sort().forEach(dateKey => {
            // Convert to timestamp for safety
            const dateObj = new Date(dateKey);
            if (isNaN(dateObj)) return;

            const pixelX = x.getPixelForValue(dateObj.getTime());
            const entry = counts[dateKey] || { c: 0, f: 0 };

            // Consumer count ‚Äì blue
            ctx.fillStyle = "rgb(54, 162, 235)";
            ctx.fillText(`c=${entry.c}`, pixelX, chart.chartArea.bottom + 20);

            // Farmer count ‚Äì green
            ctx.fillStyle = "rgb(75, 192, 75)";
            ctx.fillText(`f=${entry.f}`, pixelX, chart.chartArea.bottom + 36);
        });

        ctx.restore();
    }
};



async function fetchConsumersAndFarmersPrices() {
    const commodity = document.getElementById("commoditySelect").value;
    const startDate = document.getElementById("startDate").value;
    const endDate = document.getElementById("endDate").value;

    if (!commodity) return;

    try {
        const [consumerRes, farmerRes] = await Promise.all([
            fetch(`/api/consumers1_prices/${encodeURIComponent(commodity)}/?${startDate ? `start_date=${startDate}&` : ""}${endDate ? `end_date=${endDate}` : ""}`),
            fetch(`/api/farmers_prices/${encodeURIComponent(commodity)}/?${startDate ? `start_date=${startDate}&` : ""}${endDate ? `end_date=${endDate}` : ""}`)
        ]);

        const [consumerData, farmerData] = await Promise.all([
            consumerRes.json(),
            farmerRes.json()
        ]);

        const sortedConsumer = Array.isArray(consumerData)
            ? consumerData.sort((a, b) => new Date(a.date) - new Date(b.date))
            : [];

        const sortedFarmer = Array.isArray(farmerData)
            ? farmerData.sort((a, b) => new Date(a.date) - new Date(b.date))
            : [];

        // Extract unified sorted date list
        const dateList = [...new Set([
            ...sortedConsumer.map(d => new Date(d.date)),
            ...sortedFarmer.map(d => new Date(d.date))
        ])].sort((a, b) => a - b);

        // Prepare time-series datasets
        const consumerPrices = sortedConsumer.map(d => ({
            x: new Date(d.date),
            y: parseFloat(d.price)
        }));

        const farmerPrices = sortedFarmer.map(d => ({
            x: new Date(d.date),
            y: parseFloat(d.price)
        }));


        /* ---------------------------------------
           Separate n-counts per date (c,f)
        ---------------------------------------- */
        const dateCounts = {};

        consumerPrices.forEach(p => {
            const key = p.x.toISOString().split("T")[0];
            if (!dateCounts[key]) dateCounts[key] = { c: 0, f: 0 };
            dateCounts[key].c += 1;
        });

        farmerPrices.forEach(p => {
            const key = p.x.toISOString().split("T")[0];
            if (!dateCounts[key]) dateCounts[key] = { c: 0, f: 0 };
            dateCounts[key].f += 1;
        });


        const ctx = document.getElementById("consumersChart").getContext("2d");

        if (Chart.getChart("consumersChart")) {
            Chart.getChart("consumersChart").destroy();
        }

        consumersChart = new Chart(ctx, {
            type: "line",
            plugins: [pointCountPlugin],   // <---- IMPORTANT
            data: {
                datasets: [
                    {
                        label: gettext("Consumer Buying Price (‚Çπ)"),
                        data: consumerPrices,
                        borderColor: "rgba(54, 162, 235, 1)",
                        backgroundColor: "rgba(54, 162, 235, 0.2)",
                        borderWidth: 3,
                        showLine: false, 
                        tension: 0.3,
                        pointBorderWidth: 3,                    // bold circle border
                        pointRadius: 3,                         // bigger point
                        pointHoverRadius: 10,                   // bigger on hover
                        pointBackgroundColor: "transparent",   //rgba(0, 90, 255, 1) very dark blue
                        pointBorderColor: "rgba(0, 50, 160, 1)", 
                                    },
                    {
                        label: gettext("Farmer's Selling Price (‚Çπ)"),
                        data: farmerPrices,
                        borderColor: "rgba(75, 192, 75, 1)",
                        backgroundColor: "rgba(75, 192, 75, 0.2)",
                        borderWidth:3,
                        showLine: false, 
                        tension: 0.3,pointBorderWidth: 3,                    // bold circle border
                        pointRadius: 3,                         // bigger point
                        pointHoverRadius: 10,
                        pointBackgroundColor: "transparent",   // rgba(0, 180, 50, 1) dark green
                        pointBorderColor: "rgba(0, 120, 30, 1)",       // darker border
                    }
                ]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                parsing: false, // REQUIRED for {x,y} data
                plugins: {
                    title: {
                        display: true,
                        text: `${gettext("Consumer vs Farmer Prices for")} ${gettext(commodity)}`,
                    },
                    legend: { position: "top" },

                    // <---- PASS counts to plugin
                    pointCountPlugin: {
                        counts: dateCounts
                    },

                    zoom: {
                        zoom: {
                            wheel: { enabled: true },
                            pinch: { enabled: true },
                            mode: "xy"
                        },
                        pan: { enabled: true, mode: "xy" }
                    }
                },
                
                scales: {
                    x: {
                        type: "time",
                        offset: true,
                        time: {
                            unit: "day",
                            tooltipFormat: "dd/MM/yyyy",
                            displayFormats: { day: "dd/MM/yyyy" }
                        },
                        title: { display: true, text: "Date" }
                    },
                    y: {
                        title: { display: true, text: "Price (‚Çπ)" },
                        beginAtZero: true,
                        ticks: {
                            precision: 0,
                            callback: v => Math.round(v)
                        }
                    }
                }
            }
        });

        /** -----------------------------
         *  SLIDER SETUP (noUiSlider)
         ----------------------------- */

        const slider = document.getElementById('dateRangeSlider');
        const sliderStartLabel = document.getElementById('sliderStartLabel');
        const sliderEndLabel = document.getElementById('sliderEndLabel');

        if (slider.noUiSlider) slider.noUiSlider.destroy();

        if (dateList.length > 0) {
            noUiSlider.create(slider, {
                start: [0, dateList.length - 1],
                connect: true,
                range: { min: 0, max: dateList.length - 1 },
                step: 1
            });

            sliderStartLabel.textContent = dateList[0].toLocaleDateString("en-GB");
            sliderEndLabel.textContent = dateList[dateList.length - 1].toLocaleDateString("en-GB");

            function debounce(fn, delay) {
                let timeout;
                return (...args) => {
                    clearTimeout(timeout);
                    timeout = setTimeout(() => fn(...args), delay);
                };
            }

            const updateChart = debounce(values => {
                const startIndex = Math.floor(values[0]);
                const endIndex = Math.floor(values[1]);

                consumersChart.options.scales.x.min = dateList[startIndex];
                consumersChart.options.scales.x.max = dateList[endIndex];

                consumersChart.update('none');
            }, 100);

            slider.noUiSlider.on("update", values => {
                const startIndex = Math.floor(values[0]);
                const endIndex = Math.floor(values[1]);

                sliderStartLabel.textContent = dateList[startIndex].toLocaleDateString("en-GB");
                sliderEndLabel.textContent = dateList[endIndex].toLocaleDateString("en-GB");

                updateChart(values);
            });
        }

    } catch (err) {
        console.error("Error fetching prices:", err);
    }
}

// Attach to filter & commodity change
document.getElementById("filterByDateBtn").addEventListener("click", fetchConsumersAndFarmersPrices);
document.getElementById("commoditySelect").addEventListener("change", fetchConsumersAndFarmersPrices);

// Initial load
fetchConsumersAndFarmersPrices();
//unifoed over

// Toggle Show/Hide for all trend charts
document.querySelectorAll('.toggle-chart-btn').forEach(btn => {
  btn.addEventListener('click', () => {
    const targetId = btn.dataset.target;
    const targetCanvas = document.getElementById(targetId);

    if (targetCanvas.style.display === 'none') {
      targetCanvas.style.display = 'block';
      btn.textContent = 'Hide';
    } else {
      targetCanvas.style.display = 'none';
      btn.textContent = 'Show';
    }
  });
});


let chartPopup = null;

document.getElementById("openAllChartsBtn").addEventListener("click", openAllChartsInPopup);

function openAllChartsInPopup() {
  const chartIds = ["consumersChart", "farmerChart", "chartCanvas"]; // all your chart <canvas> IDs
  const chartImages = chartIds.map(id => {
    const canvas = document.getElementById(id);
    return canvas ? canvas.toDataURL("image/png") : null;
  }).filter(Boolean);

  // Reuse popup if it‚Äôs already open
  if (!chartPopup || chartPopup.closed) {
    chartPopup = window.open("", "chartsPopup", "width=1100,height=900");
  } else {
    chartPopup.focus();
  }

  // Write content
  chartPopup.document.open();
  chartPopup.document.write(`
    <html>
      <head>
        <title>All Charts</title>
        <style>
          body {
            margin: 0;
            background: #f9fafb;
            font-family: Arial, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start;
            padding: 20px;
            gap: 20px;
          }
          img {
            max-width: 95%;
            border: 1px solid #ccc;
            border-radius: 8px;
            box-shadow: 0 0 10px rgba(0,0,0,0.1);
          }
          button {
            position: fixed;
            top: 10px;
            right: 10px;
            padding: 6px 12px;
            background: #007bff;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
          }
        </style>
      </head>
      <body>
        <button onclick="window.close()">Close</button>
        ${chartImages.map((src, i) => `<img src="${src}" alt="Chart ${i + 1}">`).join("")}
      </body>
    </html>
  `);
  chartPopup.document.close();
}
// const labels = agmarkChart.data.labels; // e.g. ['2024-01-01', '2024-01-02', ...]
if (window.agmarkChart && agmarkChart.data) {
  const labels = agmarkChart.data.labels;
  // rest of your code using agmarkChart
} else {
  console.warn("agmarkChart not ready yet.");
  return;
}

//DOM close
});
</script>
{% endblock %}