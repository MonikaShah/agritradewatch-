{% extends 'syncapp/base.html' %}
{% load static %}

{% block title %}Consumers Map{% endblock %}

{% block extra_head %}
<script src="https://code.jquery.com/jquery-3.7.1.min.js"></script>

<link
  rel="stylesheet"
  href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
/>
<link
  rel="stylesheet"
  href="https://unpkg.com/leaflet.markercluster@1.5.3/dist/MarkerCluster.css"
/>
<link
  rel="stylesheet"
  href="https://unpkg.com/leaflet.markercluster@1.5.3/dist/MarkerCluster.Default.css"
/>
<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<script src="https://unpkg.com/leaflet.markercluster@1.5.3/dist/leaflet.markercluster.js"></script>
<link rel="stylesheet" href="{% static 'syncapp/css/map.css' %}">

<script src="https://cdn.jsdelivr.net/npm/chart.js@4.3.0/dist/chart.umd.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/chartjs-chart-box-and-violin-plot@4.0.1/dist/chartjs-chart-box-and-violin-plot.umd.min.js"></script>

<script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.4.1/papaparse.min.js"></script>
{% endblock %}

{% block content %}
<!-- Login Modal -->
<div id="loginModal" style="display:block; position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.5); z-index:1000;">
  <div style="background:white; padding:20px; margin:100px auto; width:300px; border-radius:5px;">
    <h3>Login</h3>
    <form id="loginForm">
      <input type="text" id="username" placeholder="Username" required style="width:100%; margin-bottom:10px;">
      <input type="password" id="password" placeholder="Password" required style="width:100%; margin-bottom:10px;">
      <button type="submit" style="width:100%;">Login</button>
    </form>
    <div id="loginMessage" style="margin-top:10px; color:red;"></div>
  </div>
</div>

<div id="map-container">
 <div id="map"></div>
  <div id="map-controls">
    <label for="commoditySelect"><b>Select Commodity</b></label>
    <select id="commoditySelect" class="form-control">
      {% for type, items in grouped_commodities.items %}
        <optgroup label="{{ type }}">
          {% for item in items %}
            <option value="{{ item.name }}" {% if item.disabled %}disabled{% endif %}>
              {{ item.name }}
            </option>
          {% endfor %}
        </optgroup>
      {% endfor %}
    </select>
        
    <hr>
    <div id="left-panel">
      <button id="locateBtn">üìç My Location</button>
      <label>Radius: <span id="radiusValue">100</span> m</label>
      <input type="range" id="radiusSlider" min="50" max="700" step="50" value="100" list="tickmarks">
      <datalist id="tickmarks">
        <option value="50" label="50m"></option>
        <option value="100" label="100m"></option>
        <option value="200" label="200m"></option>
        <option value="300" label="300m"></option>
        <option value="400" label="400m"></option>
        <option value="500" label="500m"></option>
        <option value="600" label="600m"></option>
        <option value="700" label="700m"></option>
      </datalist>
    </div>
    <hr>
    <button id="toggleDistrictBtn">üó∫Ô∏è Hide Districts</button>
    <hr>
    <button id="toggleApmcBtn">üõí Show All APMC</button>
  </div>
  <button id="toggle-map-controls">‚öôÔ∏è Hide/Show</button>
</div>

<div id="right-panel">
  <div class="box" id="graph-box">
    <h3>Consumer Reported Buying Price : <span id="selected-commodity"></span></h3>
    <div id="stats-container" style="display: flex; gap: 20px;">
      <div id="global-stats" style="margin-top: 4px;">
        <strong>All Consumers:</strong><br>
        Average Price: <span id="avg-price">--</span><br>
        Weighted Average: <span id="weighted-avg">--</span><br>
        Modal Price: <span id="modal-price">--</span>
      </div>
      <div id="radius-stats" style="margin-top: 4px;">
        <strong>Within Selected Radius:</strong><br>
        Average Price: <span id="avg-price-radius">--</span><br>
        Weighted Average: <span id="weighted-avg-radius">--</span><br>
        Modal Price: <span id="modal-price-radius">--</span>
      </div>
    </div>
    <hr>
    <h3>Agmarknet Price Trend : <span id="agmarknet"></span></h3>
  <!-- New: Date range selection -->
  <div id="date-range-container" style="margin-bottom: 10px;">
    <label>Start Date: <input type="date" id="startDate"></label>
    <label>End Date: <input type="date" id="endDate"></label>
    <button id="filterByDateBtn" style="margin-left: 5px; padding: 5px 10px;">Filter</button>
  </div>

  <canvas id="chartCanvas"></canvas>
</div>
    
{% endblock %}

{% block extra_js %}

<script>
// Get CSRF token from cookie
function getCookie(name) {
    let cookieValue = null;
    if (document.cookie && document.cookie !== '') {
        const cookies = document.cookie.split(';');
        for (let cookie of cookies) {
            cookie = cookie.trim();
            if (cookie.startsWith(name + '=')) {
                cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
                break;
            }
        }
    }
    return cookieValue;
}
document.addEventListener("DOMContentLoaded", function() {

  const loginModal = document.getElementById("loginModal");
  const loginForm = document.getElementById("loginForm");
  const loginMessage = document.getElementById("loginMessage");

  const apmcCsvUrl = "{% static 'APMC_names.csv' %}";
  let apmcMarkers = L.layerGroup();  // Separate layer for APMC

  const toggleApmcBtn = document.getElementById("toggleApmcBtn");
  let apmcVisible = false;

  const apmcIcon = L.icon({
    iconUrl: "{% static 'apmcM.png' %}",
    iconSize: [30, 30], // width, height
    iconAnchor: [15, 30], // point of the icon which will correspond to marker's location
    popupAnchor: [0, -30] // point from which the popup opens relative to the iconAnchor
  });

  
  // --------------------------
  // Token helpers 
  // --------------------------
  async function refreshToken(){
      const refresh = sessionStorage.getItem("refresh_token");
      if(!refresh) return false;
      try {
          const res = await fetch("/api/token/refresh/", {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({ refresh })
          });
          if(res.ok){
              const data = await res.json();
              sessionStorage.setItem("api_token", data.access);
              return true;
          } else {
              console.warn("Refresh token failed");
              return false;
          }
      } catch(err){
          console.error("Refresh token error:", err);
          return false;
      }
  }

  async function authFetch(url, options={}, retry=true){
    const token = sessionStorage.getItem("api_token");
    if(!token) throw new Error("No API token available");

    options.headers = {...options.headers,"Authorization":`Bearer ${token}`,"Content-Type":"application/json"};

    try {
        const res = await fetch(url, options);

        if(res.status === 401 && retry){
            const ok = await refreshToken();
            if(ok) return authFetch(url, options, false);
            else { 
                loginModal.style.display="block"; 
                throw new Error("Session expired, login required"); 
            }
        }

        if(res.status >= 400){ 
            try { return await res.json(); } catch(e){ return {}; }
        }

        return await res.json();

    } catch(err){
        console.error("authFetch error", err);
        return {}; 
    }
  }

  // --------------------------
  // Agrowon & Agmark fetch functions
  // --------------------------
  let agrowonChart = null;
  let agmarkChart = null;

  

  // --------------------------
  // Login form 
  // --------------------------
  loginForm.addEventListener("submit", async function (e) {
    e.preventDefault();

    const username = document.getElementById("username").value;
    const password = document.getElementById("password").value;
    const csrfToken = getCookie('csrftoken');

    try {
        const res = await fetch("/accounts/login/", {
            method: "POST",
            headers: {
                "Content-Type": "application/x-www-form-urlencoded",
                "X-CSRFToken": csrfToken
            },
            credentials: "same-origin", // important: send cookies
            body: `username=${encodeURIComponent(username)}&password=${encodeURIComponent(password)}`
        });

        if (res.ok) {
            // Login succeeded ‚Üí refresh page to show {{ user.username }}
            window.location.reload();
        } else {
            document.getElementById("loginMessage").innerText = "Invalid credentials!";
        }
    } catch (err) {
        console.error("Login error:", err);
        document.getElementById("loginMessage").innerText = "Login failed! Check console.";
    }
});

  // --------------------------
  // Auto-login check 
  // --------------------------
  (async function autoLoginCheck() {
    const token = sessionStorage.getItem("api_token");
    const refresh = sessionStorage.getItem("refresh_token");
    const username = sessionStorage.getItem("username");

    if(token) {
        // Try to use the token
        try {
            // Test a simple API endpoint to see if token is valid
            const res = await fetch("/api/consumers_geojson/", {
                headers: { "Authorization": `Bearer ${token}` }
            });
            if(res.ok){
                loginModal.style.display = "none";
                initMap();
                return;
            } 
        } catch(err){
            console.warn("Token check failed:", err);
        }
    }

    // Token invalid or missing, try refresh
    if(refresh){
        const ok = await refreshToken();
        if(ok){
            loginModal.style.display = "none";
            initMap();
            return;
        }
    }

    // No valid token or refresh -> show login modal
    loginModal.style.display = "block";
})();



  // --------------------------
  // Map initialization
  // --------------------------
  async function initMap(){
      const commoditySelect = document.getElementById("commoditySelect");
      const selectedCommoditySpan = document.getElementById("selected-commodity");
      selectedCommoditySpan.innerText = commoditySelect.value;

      const map = L.map('map',{ zoomControl: false }).setView([19.2, 73.0], 7);

      const osm = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { attribution: '&copy; OpenStreetMap' });
      const googleSat = L.tileLayer('https://mt1.google.com/vt/lyrs=s&x={x}&y={y}&z={z}', { attribution: '&copy; Google' });
      googleSat.addTo(map);
      const baseMaps = { "OpenStreetMap": osm, "Google Satellite": googleSat };
      L.control.layers(baseMaps, null, { position: 'topright' }).addTo(map);
      L.control.zoom({ position: 'topright' }).addTo(map);

      const markers = L.markerClusterGroup();
      let geojsonLayer = null;
      let allData = null;
      let userLocation = null;
      let userMarker = null;
      let radiusCircle = null;

      const radiusSlider = document.getElementById("radiusSlider");
      const radiusValue = document.getElementById("radiusValue");

      function drawCircle(radius){
          if(!userLocation) return;
          if(radiusCircle) map.removeLayer(radiusCircle);
          radiusCircle = L.circle(userLocation, { radius: radius, color:"red", fillOpacity:0.05 }).addTo(map);
      }

      function computeStats(features, center=null, radius=null){
          let filtered = features;
          if(center && radius){
              filtered = features.filter(f=>{
                  const latlng = L.latLng(f.geometry.coordinates[1], f.geometry.coordinates[0]);
                  return center.distanceTo(latlng)<=radius;
              });
          }
          if(filtered.length === 0) return {avg:null, weighted:null, modal:null};
          const prices = filtered.map(f=>f.properties.buyingprice).filter(v=>v!==null);
          const unit = filtered.map(f => f.properties.unit).find(u => u !== null && u !== undefined) || '';
          const quantities = filtered.map(f=>f.properties.quantitybought).map(q=>q||1);
          const avg = prices.reduce((a,b)=>a+b,0)/prices.length;
          const weighted = prices.reduce((sum,p,i)=>sum+p*quantities[i],0)/quantities.reduce((a,b)=>a+b,0);
          const freq={}; prices.forEach(p=>freq[p]=(freq[p]||0)+1);
          let modal=prices[0], maxCount=0;
          for(const k in freq){ if(freq[k]>maxCount){ modal=k; maxCount=freq[k]; } }
          return {avg, weighted, modal};
      }

      function showGlobalStats(stats){
          document.getElementById("avg-price").innerText = stats.avg!==null ?` ‚Çπ${stats.avg.toFixed(2)} ${stats.unit || ''}`: "No data";
          document.getElementById("weighted-avg").innerText = stats.weighted!==null ? stats.weighted.toFixed(2) : "No data";
          document.getElementById("modal-price").innerText = stats.modal!==null ? `‚Çπ${stats.modal}` : "No data";
      }

      function showRadiusStats(stats){
          document.getElementById("avg-price-radius").innerText = stats.avg!==null ? stats.avg.toFixed(2) : "No data";
          document.getElementById("weighted-avg-radius").innerText = stats.weighted!==null ? stats.weighted.toFixed(2) : "No data";
          document.getElementById("modal-price-radius").innerText = stats.modal!==null ? stats.modal : "No data";
      }

      function updateStatsForRadius(){
        if(!allData || !Array.isArray(allData.features)) return;
        const commodity = commoditySelect.value.toLowerCase();
        const filtered = allData.features.filter(f => f.properties?.commodity?.toLowerCase() === commodity);
        showGlobalStats(computeStats(filtered));
        if(userLocation) showRadiusStats(computeStats(filtered, userLocation, parseInt(radiusSlider.value)));
        else showRadiusStats({avg:null, weighted:null, modal:null});
      }

      function updateMarkers(commodity, zoomToBounds=false){
          markers.clearLayers();
          if(geojsonLayer) map.removeLayer(geojsonLayer);
          if(!allData || !Array.isArray(allData.features)) return;

          const indiaBounds = L.latLngBounds([6.5,68.0],[35.5,97.5]);
          const filteredFeatures = allData.features.filter(f=>{
              const latlng = L.latLng(f.geometry.coordinates[1], f.geometry.coordinates[0]);
              return indiaBounds.contains(latlng) && f.properties.commodity?.toLowerCase() === commodity.toLowerCase();
          });

          const filteredGeoJSON = { type:"FeatureCollection", features: filteredFeatures };
          geojsonLayer = L.geoJSON(filteredGeoJSON, {
              pointToLayer:(f,latlng)=>{
                  let color="red";
                  if(userLocation && userLocation.distanceTo(latlng)<=parseInt(radiusSlider.value)) color="green";
                  return L.circleMarker(latlng,{radius:8, fillColor:color, color:"#000", weight:1, opacity:1, fillOpacity:0.8});
              },
              onEachFeature:(f,layer)=>{
                  const p=f.properties;
                  // layer.bindPopup(`<strong>Consumer Name:</strong>${p.username || "Unknown"}<br><strong>Commodity Purchaed:</strong>${p.commodity || "Unknown"}<br>Purchase Date: </strong>${p.date? `<em>${new Date(p.date).toLocaleDateString('en-GB')}</em><br>`:""}Consumer Buying Price:</strong> ${p.buyingprice||'NA'}<br>Quantity Bought:</strong> ${p.quantitybought||'-'} ${p.unit||''}<br>`);
                  // Build table HTML
                  const table = `
                      <table style="border-collapse: collapse; width: 100%;">
                          
                          <tr>
                              <td style="border: 1px solid #999; padding: 4px;">Consumer Name</td>
                              <td style="border: 1px solid #999; padding: 4px;">${p.username || "Unknown"}</td>
                          </tr>
                          <tr>
                              <td style="border: 1px solid #999; padding: 4px;">Commodity Purchased</td>
                              <td style="border: 1px solid #999; padding: 4px;">${p.commodity || "Unknown"}</td>
                          </tr>
                          <tr>
                              <td style="border: 1px solid #999; padding: 4px;">Purchase Date</td>
                              <td style="border: 1px solid #999; padding: 4px;">${p.date ? new Date(p.date).toLocaleDateString('en-GB') : "-"}</td>
                          </tr>
                          <tr>
                              <td style="border: 1px solid #999; padding: 4px;">Buying Price</td>
                              <td style="border: 1px solid #999; padding: 4px;">${p.buyingprice || 'NA'}</td>
                          </tr>
                          <tr>
                              <td style="border: 1px solid #999; padding: 4px;">Quantity Bought</td>
                              <td style="border: 1px solid #999; padding: 4px;">${p.quantitybought || '-'} ${p.unit || ''}</td>
                          </tr>
                      </table>
                  `;

                  layer.bindPopup(table);
              }
          });
          markers.addLayer(geojsonLayer); map.addLayer(markers);

          if(zoomToBounds && (filteredFeatures.length>0 || userLocation)){
              let bounds = markers.getBounds();
              if(userLocation){ bounds.extend(userLocation); if(radiusCircle) bounds.extend(radiusCircle.getBounds()); }
              map.fitBounds(bounds,{padding:[30,30]});
          }
      }

      // --- Geolocation ---
      document.getElementById("locateBtn").addEventListener("click", ()=>{
          if(navigator.geolocation){
              navigator.geolocation.getCurrentPosition(pos=>{
                  userLocation = L.latLng(pos.coords.latitude,pos.coords.longitude);
                  if(userMarker) map.removeLayer(userMarker);
                  userMarker = L.marker(userLocation,{draggable:true,title:"APMC"}).addTo(map);
                  userMarker.on("dragend",e=>{ 
                      userLocation=e.target.getLatLng(); 
                      drawCircle(parseInt(radiusSlider.value)); 
                      updateStatsForRadius(); 
                      updateMarkers(commoditySelect.value,true); 
                  });
                  drawCircle(parseInt(radiusSlider.value));
                  updateStatsForRadius();
                  updateMarkers(commoditySelect.value,true);
              });
          } else alert("Geolocation not supported by your browser.");
      });

      radiusSlider.addEventListener("input", function(){
          radiusValue.textContent=this.value;
          if(userLocation){ 
              drawCircle(parseInt(this.value)); 
              updateStatsForRadius(); 
              updateMarkers(commoditySelect.value,false); 
          }
      });

      // --- Fetch initial data ---
      try {
          allData = await fetch("/api/consumers_geojson/");
          updateStatsForRadius(); 
          updateMarkers(commoditySelect.value,true);
      } catch(err){
          console.error("Error loading GeoJSON:", err);
      }

      commoditySelect.addEventListener("change", function(){
          selectedCommoditySpan.innerText=this.value;
          updateStatsForRadius();
          updateMarkers(this.value,true);
          
         
      });
      let districtLayer = null;

      
      toggleApmcBtn.addEventListener("click", async () => {
        if(!apmcVisible){
            try {
                const response = await fetch("/api/apmc/");  // fetch from DB
                const data = await response.json();

                data.forEach(row => {
                    const lat = parseFloat(row.latitude);
                    const lng = parseFloat(row.longitude);
                    if(!isNaN(lat) && !isNaN(lng)){
                        const marker = L.circleMarker([lat, lng], {
                            radius: 10,
                            color: 'blue',
                            weight: 2,
                            fillColor: 'red',
                            fillOpacity: 0.3
                        }).bindPopup(`<strong>Mandi Name: ${row.apmc_name}</strong><br>District: ${row.district}<br><a href="#" class="apmc-link" data-apmc="${row.apmc_name}">View Timeline</a>`);
                        apmcMarkers.addLayer(marker);
                    }
                });

                apmcMarkers.addTo(map);
                apmcVisible = true;
                toggleApmcBtn.innerText = "üìç Hide APMC";

            } catch(err){
                console.error("Error fetching APMC from DB:", err);
            }
        } else {
            map.removeLayer(apmcMarkers);
            apmcVisible = false;
            toggleApmcBtn.innerText = "üìç Show All APMC";
        }
    });

      const toggleDistrictBtn = document.getElementById("toggleDistrictBtn");
        let districtVisible = true;

        toggleDistrictBtn.addEventListener("click", () => {
          if(!districtLayer || !districtLayer.addTo) return; // safety check

          if(districtVisible){
              map.removeLayer(districtLayer);
              districtVisible = false;
              toggleDistrictBtn.innerText = "üó∫Ô∏è Show Districts";
          } else {
              districtLayer.addTo(map);
              districtVisible = true;
              toggleDistrictBtn.innerText = "üó∫Ô∏è Hide Districts";
          }
        });
      
        try {
              const districtResponse = await fetch("{% static 'districts_rev21june23.geojson' %}");
              const districtData = await districtResponse.json();
              
              districtLayer = L.geoJSON(districtData, {
                  style: { color: "#3388ff", weight: 2, fillOpacity: 0.1 }
              }).addTo(map); // initially visible
          } catch(err){
              console.error("Error loading district GeoJSON:", err);
          } 
        
        // InitMap ends here
      // --- Initial chart fetch ---
     
      document.getElementById('toggle-map-controls').addEventListener('click',()=>document.getElementById('map-controls').classList.toggle('collapsed'));

      function showTimeline(apmcName) {
        const url = `/apmc/${encodeURIComponent(apmcName)}/timeline-ajax/`;

        fetch(url)
            .then(res => res.text())
            .then(data => {
                const modalBody = document.querySelector('#apmcTimelineModal .modal-body');
                modalBody.innerHTML = data;

                // Show modal
                const modalEl = document.getElementById('apmcTimelineModal');
                const modal = new bootstrap.Modal(modalEl);
                modal.show();

                // Parse table rows
                const pricesRows = modalBody.querySelectorAll('tbody tr');
                const labels = [];
                const modalPrices = [];

                pricesRows.forEach(row => {
                    const date = row.cells[0].innerText;
                    const price = row.cells[6].innerText.replace(/,/g,'');
                    if(price){
                        labels.push(date);
                        modalPrices.push(parseFloat(price));
                    }
                });

                // Render chart after modal shown
                setTimeout(() => {
                    const ctx = modalBody.querySelector('#apmcTimelineChart').getContext('2d');

                    // Destroy previous chart only if it's a valid Chart instance
                    if(window.apmcTimelineChart instanceof Chart){
                        window.apmcTimelineChart.destroy();
                    }

                    window.apmcTimelineChart = new Chart(ctx, {
                        type: 'line',
                        data: {
                            labels: labels,
                            datasets: [{
                                label: 'Modal Price (‚Çπ/Quintal)',
                                data: modalPrices,
                                fill: false,
                                borderColor: 'rgba(75, 192, 192, 1)',
                                backgroundColor: 'rgba(75, 192, 192, 0.2)',
                                tension: 0.1
                            }]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            plugins: { legend: { position: 'top' }, title: { display: true, text: 'Modal Price Trend' } },
                            scales: {
                                x: { title: { display: true, text: 'Date' } },
                                y: { title: { display: true, text: 'Price (‚Çπ)' } }
                            }
                        }
                    });
                }, 200);

            })
            .catch(err => console.error(err));
    }

      // Attach event listener
      document.addEventListener('click', function(e){
        const target = e.target.closest('.apmc-link');
        if(target){
            e.preventDefault();
            const apmcName = target.dataset.apmc;
            showTimeline(apmcName);
        }
    });

   // Fetch Agmark Price and draw line chart
    let agmarkChart = null;
    let chartData = [];  // Store API response globally for tooltips

    document.getElementById("filterByDateBtn").addEventListener("click", async () => {
        const startDate = document.getElementById("startDate").value;
        const endDate = document.getElementById("endDate").value;
        const commodity = document.getElementById("commoditySelect").value;

        if (!commodity) return alert("Select a commodity first.");

        try {
            const url = `/api/webdata_prices/?commodity=${encodeURIComponent(commodity)}${startDate ? `&start_date=${startDate}` : ''}${endDate ? `&end_date=${endDate}` : ''}`;
            const data = await fetch(url);

            if (data.error) {
                alert(data.error);
                return;
            }

            chartData = data;  // <-- Save globally for tooltip access

            // Extract labels and price arrays
            const labels = data.map(d =>{ 
                if(!d.date) return '';
                const dt = new Date(d.date);
                return dt.toLocaleDateString('en-GB');  // outputs DD/MM/YYYY
            });
            const minPrices = data.map(d => parseFloat(d.minprice));
            const maxPrices = data.map(d => parseFloat(d.maxprice));
            const modalPrices = data.map(d => parseFloat(d.modalprice));

            const ctx = document.getElementById("chartCanvas").getContext("2d");

            // Destroy previous chart
            if (agmarkChart instanceof Chart) agmarkChart.destroy();

            agmarkChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: labels,
                    datasets: [
                        { label: 'Min Price', data: minPrices, borderColor: 'green', backgroundColor: 'rgba(0,128,0,0.1)', tension: 0.1 },
                        { label: 'Max Price', data: maxPrices, borderColor: 'red', backgroundColor: 'rgba(255,0,0,0.1)', tension: 0.1 },
                        { label: 'Modal Price', data: modalPrices, borderColor: 'blue', backgroundColor: 'rgba(0,0,255,0.1)', tension: 0.1 }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { position: 'top' },
                        title: { display: true, text: `${commodity} Price Trend per Qunital` },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    const price = context.raw;
                                    const datasetLabel = context.dataset.label;
                                    const index = context.dataIndex;
                                    const apmcName = chartData[index].apmc_name || "Unknown APMC";
                                    return `${datasetLabel}: ‚Çπ${price} (${apmcName})`;
                                }
                            }
                        }
                    },
                    scales: {
                        x: { title: { display: true, text: 'Date' } },
                        y: { title: { display: true, text: 'Price (‚Çπ)' } }
                    }
                }
            });

        } catch(err){
            console.error("Error fetching webdata prices:", err);
            alert("Failed to load prices. Check console.");
        }
    });

  }//InitMap close

  // --------------------------
// Web login via Django session
// --------------------------
loginForm.addEventListener("submit", async function (e) {
  e.preventDefault();

  const username = document.getElementById("username").value;
  const password = document.getElementById("password").value;

  try {
    // Send POST request to Django session login endpoint
    const res = await fetch("/accounts/login/", {
      method: "POST",
      headers: { "Content-Type": "application/x-www-form-urlencoded" },
      body: `username=${encodeURIComponent(username)}&password=${encodeURIComponent(password)}`
    });

    if (res.ok) {
      // Login successful ‚Üí reload page to update {{ user }}
      window.location.reload();
    } else {
      // Login failed
      document.getElementById("loginMessage").innerText = "Invalid credentials!";
    }
  } catch (err) {
    console.error("Login error:", err);
    document.getElementById("loginMessage").innerText = "Login failed! Check console.";
  }
});



});
</script>
{% endblock %}