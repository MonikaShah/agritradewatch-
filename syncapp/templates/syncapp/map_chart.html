{% extends 'syncapp/base.html' %}
{% load static %}

{% block title %}Consumers Map{% endblock %}

{% block extra_head %}
<script src="https://code.jquery.com/jquery-3.7.1.min.js"></script>

<link
  rel="stylesheet"
  href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
/>
<link
  rel="stylesheet"
  href="https://unpkg.com/leaflet.markercluster@1.5.3/dist/MarkerCluster.css"
/>
<link
  rel="stylesheet"
  href="https://unpkg.com/leaflet.markercluster@1.5.3/dist/MarkerCluster.Default.css"
/>
<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<script src="https://unpkg.com/leaflet.markercluster@1.5.3/dist/leaflet.markercluster.js"></script>
<link rel="stylesheet" href="{% static 'syncapp/css/map.css' %}">

<script src="https://cdn.jsdelivr.net/npm/chart.js@4.3.0/dist/chart.umd.min.js"></script>


<script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.4.1/papaparse.min.js"></script>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nouislider@15.7.0/dist/nouislider.min.css" />
<script src="https://cdn.jsdelivr.net/npm/nouislider@15.7.0/dist/nouislider.min.js"></script>


<style>
  .resizable-chart {
    width: 100% !important;
    max-height: 300px;
    transition: max-height 0.3s ease;
  }

  .resizable-chart.expanded {
    max-height: 600px;
  }
  .toggle-chart-btn {
  font-size: 0.8rem;
  background-color: #f8f9fa;
  border: 1px solid #ccc;
  border-radius: 5px;
  padding: 2px 8px;
  margin-left: 10px;
  cursor: pointer;
  transition: background 0.2s ease;
}
.toggle-chart-btn:hover {
  background-color: #e2e6ea;
}
.chart-container {
  width: 100%;
  height: 300px;              /* default compact height */
  transition: height 0.28s ease;
  position: relative;
}

/* make the canvas fill the container */
.chart-container canvas {
  width: 100% !important;
  height: 100% !important;    /* Chart.js respects canvas height property */
  display: block;
}

/* expanded state */
.chart-container.expanded {
  height: 600px;              /* expanded height */
}
#dateRangeSlider {
  margin-top: 10px;
}
.noUi-handle {
  background-color: #007bff;
  border: 2px solid #0056b3;
  box-shadow: none;
}
.noUi-connect {
  background: #80bdff;
}

</style>
{% endblock %}

{% block content %}
<!-- Login Modal -->
<div id="loginModal" style="display:block; position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.5); z-index:1000;">
  <div style="background:white; padding:20px; margin:100px auto; width:300px; border-radius:5px;">
    <h3>Login</h3>
    <form id="loginForm">
      <input type="text" id="username" placeholder="Username" required style="width:100%; margin-bottom:10px;">
      <input type="password" id="password" placeholder="Password" required style="width:100%; margin-bottom:10px;">
      <button type="submit" style="width:100%;">Login</button>
    </form>
    <div id="loginMessage" style="margin-top:10px; color:red;"></div>
  </div>
</div>


<div id="map-container">
 <div id="map"></div>
  <div id="map-controls">
    <label for="commoditySelect"><b>Select Commodity</b></label>
    <select id="commoditySelect" class="form-control">
      {% for type, items in grouped_commodities.items %}
        <optgroup label="{{ type }}">
          {% for item in items %}
            <option value="{{ item.name }}" {% if item.disabled %}disabled{% endif %}>
              {{ item.name }}
            </option>
          {% endfor %}
        </optgroup>
      {% endfor %}
    </select>
        
    <!-- Show total commodity count -->
    <p id="commodityCount" style="margin-top: 5px; font-weight: bold; color: #333;"></p>
    
    <hr>
    <div id="left-panel">
      <button id="locateBtn">üìç My Location</button>
      <label>Radius: <span id="radiusValue">100</span></label>
      <input type="range" id="radiusSlider" min="1" max="8" value="2" step="1" list="tickmarks">
        <datalist id="tickmarks">
        <option value="1" label="50 m"></option>
        <option value="2" label="100 m"></option>
        <option value="3" label="500 m"></option>
        <option value="4" label="1 km"></option>
        <option value="5" label="5 km"></option>
        <option value="6" label="20 km"></option>
        <option value="7" label="100 km"></option>
        <option value="8" label="500 km"></option>
        </datalist>

    </div>
    <hr>
    <button id="toggleDistrictBtn">üó∫Ô∏è Hide Districts</button>
    <!-- <hr> -->
    <!-- <button id="toggleApmcBtn">üõí Show All APMC</button> -->
  </div>
  <button id="toggle-map-controls">‚öôÔ∏è Hide/Show</button>
</div>

<div id="right-panel">
  <div class="box" id="graph-box">
    <h3>Consumer Reported Buying Price : <span id="selected-commodity"></span></h3>
    <div id="stats-container" style="display: flex; gap: 20px;">
      <div id="global-stats" style="margin-top: 4px;">
        <strong>All Consumers:</strong><br>
        Average Price: <span id="avg-price">--</span><br>
        Weighted Average: <span id="weighted-avg">--</span><br>
        Modal Price: <span id="modal-price">--</span>
      </div> 
      <div id="radius-stats" style="margin-top: 4px;">
        <strong>Within Selected Radius:</strong><br>
        Average Price: <span id="avg-price-radius">--</span><br>
        Weighted Average: <span id="weighted-avg-radius">--</span><br>
        Modal Price: <span id="modal-price-radius">--</span>
      </div>
    </div> <!--# stats-container div close -->
    <hr>
    <div style="text-align: right; margin-bottom: 10px;">
      <button id="openAllChartsBtn" class="btn btn-primary">‚ÜóÔ∏è Open All Charts</button>
    </div>
    
    <hr>
    <h3>Consumers Buying Price Trend : <span id="consumerapan"></span>
      <button class="toggle-chart-btn" data-target="consumersChart">Hide Chart</button>
      <!-- <button class="resize-chart-btn" data-target="consumersChart">Expand</button> -->
    </h3>
      <!-- New: Date range selection -->
      <div id="date-range-container1" style="margin-bottom: 10px;">
        <label>Start Date: <input type="date" id="startDate1"></label>
        <label>End Date: <input type="date" id="endDate1"></label>
        <button id="filterByDateBtn1" style="margin-left: 5px; padding: 5px 10px;">Filter</button>
      </div>
      <!-- <div class="chart-container" id="consumersChartContainer">
        <canvas id="consumersChart"></canvas>
      </div> -->
      <canvas id="consumersChart" class="resizable-chart"></canvas>

      <hr>
      <h3>Farmers Selling Price Trend : <span id="farmerspan"></span>
        <button class="toggle-chart-btn" data-target="farmerChart">Hide Chart</button>
        <!-- <button class="resize-chart-btn" data-target="farmerChart">Expand</button> -->
      </h3>
      <!-- New: Date range selection -->
      <div id="date-range-container2" style="margin-bottom: 10px;">
        <label>Start Date: <input type="date" id="startDate2"></label>
        <label>End Date: <input type="date" id="endDate2"></label>
        <button id="filterByDateBtn2" style="margin-left: 5px; padding: 5px 10px;">Filter</button>
      </div>
      <canvas id="farmerChart" class="resizable-chart"></canvas>
      <!-- <div class="chart-container" id="farmerChartContainer">
        <canvas id="farmerChart"></canvas>
      </div> -->

    <hr>
    <h3>Agmarknet Price Trend : <span id="agmarknet"></span>
      <button class="toggle-chart-btn" data-target="chartCanvas">Hide Chart</button>
      <!-- <button class="resize-chart-btn" data-target="chartCanvas">Expand</button> -->
    </h3>
    <!-- New: Date range selection -->
    <div id="date-range-container" style="margin-bottom: 10px;">
      <label>Start Date: <input type="date" id="startDate"></label>
      <label>End Date: <input type="date" id="endDate"></label>
      <button id="filterByDateBtn" style="margin-left: 5px; padding: 5px 10px;">Filter</button>
    </div>
    
     <div class="chart-x-slider-container">
      <canvas id="chartCanvas"></canvas>
      <div id="dateRangeSlider" class="mt-3" style="width: 80%; margin: auto;"></div>
      <div id="dateRangeLabel" style="text-align:center; margin-top: 6px; font-size: 0.9rem;"></div>
    </div>



  </div><!--# graph-box div close -->
</div><!--# <right>-panel div close -->
{% endblock %}

{% block extra_js %}
<script>
document.addEventListener("DOMContentLoaded", function() {

  const loginModal = document.getElementById("loginModal");
  const loginForm = document.getElementById("loginForm");
  const loginMessage = document.getElementById("loginMessage");

  const apmcCsvUrl = "{% static 'APMC_names.csv' %}";
  let apmcMarkers = L.layerGroup();  // Separate layer for APMC

//   const toggleApmcBtn = document.getElementById("toggleApmcBtn");
  let apmcVisible = false;

  const apmcIcon = L.icon({
    iconUrl: "{% static 'apmcM.png' %}",
    iconSize: [30, 30], // width, height
    iconAnchor: [15, 30], // point of the icon which will correspond to marker's location
    popupAnchor: [0, -30] // point from which the popup opens relative to the iconAnchor
  });

  
  // --------------------------
  // Token helpers 
  // --------------------------
  async function refreshToken(){
      const refresh = sessionStorage.getItem("refresh_token");
      if(!refresh) return false;
      try {
          const res = await fetch("/api/token/refresh/", {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({ refresh })
          });
          if(res.ok){
              const data = await res.json();
              sessionStorage.setItem("api_token", data.access);
              return true;
          } else {
              console.warn("Refresh token failed");
              return false;
          }
      } catch(err){
          console.error("Refresh token error:", err);
          return false;
      }
  }

  async function authFetch(url, options={}, retry=true){
    const token = sessionStorage.getItem("api_token");
    if(!token) throw new Error("No API token available");

    options.headers = {...options.headers,"Authorization":`Bearer ${token}`,"Content-Type":"application/json"};

    try {
        const res = await fetch(url, options);

        if(res.status === 401 && retry){
            const ok = await refreshToken();
            if(ok) return authFetch(url, options, false);
            else { 
                loginModal.style.display="block"; 
                throw new Error("Session expired, login required"); 
            }
        }

        if(res.status >= 400){ 
            try { return await res.json(); } catch(e){ return {}; }
        }

        return await res.json();

    } catch(err){
        console.error("authFetch error", err);
        return {}; 
    }
  }

  // --------------------------
  // Agrowon & Agmark fetch functions
  // --------------------------
    let agmarkChart = null;
    let agmarkData = [];

// --------------------------
  // Login form 
  // --------------------------
  loginForm.addEventListener("submit", async function (e) {
    e.preventDefault();
    const username = document.getElementById("username").value;
    const password = document.getElementById("password").value;

    try {
      const res = await fetch("/api/token/", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ username, password }),
      });
      const data = await res.json();
      if(data.access){
        if(!sessionStorage.getItem("api_token") && localStorage.getItem("api_token")){
            sessionStorage.setItem("api_token", localStorage.getItem("api_token"));
            sessionStorage.setItem("refresh_token", localStorage.getItem("refresh_token"));
            sessionStorage.setItem("username", localStorage.getItem("username"));
        } 
          localStorage.setItem("username", username);
          localStorage.setItem("api_token", data.access);
          localStorage.setItem("refresh_token", data.refresh);
          loginModal.style.display = "none";
          initMap();
      } else {
          loginMessage.innerText = data.detail || "Login failed!";
      }
    } catch(err){
        console.error("Login error:", err);
        loginMessage.innerText = "Login failed! Check console.";
    }
  });

  // --------------------------
  // Auto-login check 
  // --------------------------
  (async function autoLoginCheck() {
    const token = sessionStorage.getItem("api_token");
    const refresh = sessionStorage.getItem("refresh_token");
    const username = sessionStorage.getItem("username");

    if(token) {
        // Try to use the token
        try {
            // Test a simple API endpoint to see if token is valid
            const res = await fetch("/api/consumers_geojson/", {
                headers: { "Authorization": `Bearer ${token}` }
            });
            if(res.ok){
                loginModal.style.display = "none";
                initMap();
                return;
            } 
        } catch(err){
            console.warn("Token check failed:", err);
        }
    }

    // Token invalid or missing, try refresh
    if(refresh){
        const ok = await refreshToken();
        if(ok){
            loginModal.style.display = "none";
            initMap();
            return;
        }
    }

    // No valid token or refresh -> show login modal
    loginModal.style.display = "block";
  })();



  // --------------------------
  // Map initialization
  // --------------------------
  async function initMap(){
      const commoditySelect = document.getElementById("commoditySelect");
      const selectedCommoditySpan = document.getElementById("selected-commodity");
      selectedCommoditySpan.innerText = commoditySelect.value;

      const map = L.map('map',{ zoomControl: false }).setView([19.2, 73.0], 7);

      const osm = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { attribution: '&copy; OpenStreetMap' });
    //   const googleSat = L.tileLayer('https://mt1.google.com/vt/lyrs=s&x={x}&y={y}&z={z}', { attribution: '&copy; Google' });
      const googleSat= L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Street_Map/MapServer/tile/{z}/{y}/{x}', {
      attribution: '&copy; Esri, HERE, Garmin, ¬© OpenStreetMap contributors'
      });
      const googleSat1 = L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/Reference/World_Boundaries_and_Places/MapServer/tile/{z}/{y}/{x}', {
      maxZoom: 19,
      attribution: ''
      });
      //googleSat.addTo(map);
      osm.addTo(map);
      const satelliteWithBoundaries = L.layerGroup([googleSat, googleSat1]);
      const baseMaps = { "OpenStreetMap": osm, "Google Satellite": googleSat };
    //   const baseMaps = { "OpenStreetMap": osm, "Google Satellite": googleSat };
      L.control.layers(baseMaps, null, { position: 'topright' }).addTo(map);
      L.control.zoom({ position: 'topright' }).addTo(map);

      const markers = L.markerClusterGroup();
      let geojsonLayer = null;
      let allData = null;
      let userLocation = null;
      let userMarker = null;
      let radiusCircle = null;

      const radiusSlider = document.getElementById("radiusSlider");
      const radiusValue = document.getElementById("radiusValue");
      const scale = {
                    1: 50,
                    2: 100,
                    3: 500,
                    4: 1000,
                    5: 5000,
                    6: 20000,
                    7: 100000,
                    8: 500000
        };

      function drawCircle(radius){
          if(!userLocation) return;
          if(radiusCircle) map.removeLayer(radiusCircle);
          radiusCircle = L.circle(userLocation, { radius: radius, color:"red", fillOpacity:0.05 }).addTo(map);
      }

      function computeStats(features, center=null, radius=null){
          let filtered = features;
          if(center && radius){
              filtered = features.filter(f=>{
                  const latlng = L.latLng(f.geometry.coordinates[1], f.geometry.coordinates[0]);
                  return center.distanceTo(latlng)<=radius;
              });
          }
          if(filtered.length === 0) return {avg:null, weighted:null, modal:null};
          const prices = filtered.map(f=>f.properties.buyingprice).filter(v=>v!==null);
          const unit = filtered.map(f => f.properties.unit).find(u => u !== null && u !== undefined) || '';
          const quantities = filtered.map(f=>f.properties.quantitybought).map(q=>q||1);
          const avg = prices.reduce((a,b)=>a+b,0)/prices.length;
          const weighted = prices.reduce((sum,p,i)=>sum+p*quantities[i],0)/quantities.reduce((a,b)=>a+b,0);
          const freq={}; prices.forEach(p=>freq[p]=(freq[p]||0)+1);
          let modal=prices[0], maxCount=0;
          for(const k in freq){ if(freq[k]>maxCount){ modal=k; maxCount=freq[k]; } }
          return {avg, weighted, modal};
      }

      function showGlobalStats(stats){
          document.getElementById("avg-price").innerText = stats.avg!==null ?` ‚Çπ${stats.avg.toFixed(2)} ${stats.unit || ''}`: "No data";
          document.getElementById("weighted-avg").innerText = stats.weighted!==null ? stats.weighted.toFixed(2) : "No data";
          document.getElementById("modal-price").innerText = stats.modal!==null ? `‚Çπ${stats.modal}` : "No data";
      }

      function showRadiusStats(stats){
          document.getElementById("avg-price-radius").innerText = stats.avg!==null ? stats.avg.toFixed(2) : "No data";
          document.getElementById("weighted-avg-radius").innerText = stats.weighted!==null ? stats.weighted.toFixed(2) : "No data";
          document.getElementById("modal-price-radius").innerText = stats.modal!==null ? stats.modal : "No data";
      }

      function updateStatsForRadius(){
        if(!allData || !Array.isArray(allData.features)) return;
        const commodity = commoditySelect.value.toLowerCase();
        const filtered = allData.features.filter(f => f.properties?.commodity?.toLowerCase() === commodity);
        showGlobalStats(computeStats(filtered));
        if(userLocation) showRadiusStats(computeStats(filtered, userLocation, scale[radiusSlider.value]));
        else showRadiusStats({avg:null, weighted:null, modal:null});
      }

      function updateMarkers(commodity, zoomToBounds=false){
          markers.clearLayers();
          if(geojsonLayer) map.removeLayer(geojsonLayer);
          if(!allData || !Array.isArray(allData.features)) return;

          const indiaBounds = L.latLngBounds([6.5,68.0],[35.5,97.5]);
          const filteredFeatures = allData.features.filter(f=>{
              const latlng = L.latLng(f.geometry.coordinates[1], f.geometry.coordinates[0]);
              const dbName = f.properties.commodity?.trim().toLowerCase();
              const selected = commodity.trim().toLowerCase();
              return indiaBounds.contains(latlng) && dbName === selected;          });

          const filteredGeoJSON = { type:"FeatureCollection", features: filteredFeatures };
          geojsonLayer = L.geoJSON(filteredGeoJSON, {
              pointToLayer:(f,latlng)=>{
                  let color="red";
                  if(userLocation && userLocation.distanceTo(latlng)<=scale[radiusSlider.value]) color="green";
                  return L.circleMarker(latlng,{radius:8, fillColor:color, color:"#000", weight:1, opacity:1, fillOpacity:0.8});
              },
              onEachFeature:(f,layer)=>{
                  const p=f.properties;
                  // layer.bindPopup(`<strong>Consumer Name:</strong>${p.username || "Unknown"}<br><strong>Commodity Purchaed:</strong>${p.commodity || "Unknown"}<br>Purchase Date: </strong>${p.date? `<em>${new Date(p.date).toLocaleDateString('en-GB')}</em><br>`:""}Consumer Buying Price:</strong> ${p.buyingprice||'NA'}<br>Quantity Bought:</strong> ${p.quantitybought||'-'} ${p.unit||''}<br>`);
                  // Build table HTML
                  const table = `
                      <table style="border-collapse: collapse; width: 100%;">
                          
                          <tr>
                              <td style="border: 1px solid #999; padding: 4px;">Consumer Name</td>
                              <td style="border: 1px solid #999; padding: 4px;">${p.username || "Unknown"}</td>
                          </tr>
                          <tr>
                              <td style="border: 1px solid #999; padding: 4px;">Commodity Purchased</td>
                              <td style="border: 1px solid #999; padding: 4px;">${p.commodity || "Unknown"}</td>
                          </tr>
                          <tr>
                              <td style="border: 1px solid #999; padding: 4px;">Purchase Date</td>
                              <td style="border: 1px solid #999; padding: 4px;">${p.date ? new Date(p.date).toLocaleDateString('en-GB') : "-"}</td>
                          </tr>
                          <tr>
                              <td style="border: 1px solid #999; padding: 4px;">Buying Price</td>
                              <td style="border: 1px solid #999; padding: 4px;">${p.buyingprice || 'NA'}</td>
                          </tr>
                          <tr>
                              <td style="border: 1px solid #999; padding: 4px;">Quantity Bought</td>
                              <td style="border: 1px solid #999; padding: 4px;">${p.quantitybought || '-'} ${p.unit || ''}</td>
                          </tr>
                      </table>
                  `;

                  layer.bindPopup(table);
              }
          });
          markers.addLayer(geojsonLayer); map.addLayer(markers);

          if(zoomToBounds && (filteredFeatures.length>0 || userLocation)){
              let bounds = markers.getBounds();
              if(userLocation){ bounds.extend(userLocation); if(radiusCircle) bounds.extend(radiusCircle.getBounds()); }
              map.fitBounds(bounds,{padding:[30,30]});
          }
      }

      // --- Geolocation ---
      document.getElementById("locateBtn").addEventListener("click", ()=>{
          if(navigator.geolocation){
              navigator.geolocation.getCurrentPosition(pos=>{
                  userLocation = L.latLng(pos.coords.latitude,pos.coords.longitude);
                  if(userMarker) map.removeLayer(userMarker);
                  userMarker = L.marker(userLocation,{draggable:true,title:"APMC"}).addTo(map);
                  userMarker.on("dragend",e=>{ 
                      userLocation=e.target.getLatLng(); 
                      drawCircle(scale[radiusSlider.value]); 
                      updateStatsForRadius(); 
                      updateMarkers(commoditySelect.value,true); 
                  });
                  drawCircle(scale[radiusSlider.value]);
                  updateStatsForRadius();
                  updateMarkers(commoditySelect.value,true);
              });
          } else alert("Geolocation not supported by your browser.");
      });

      radiusSlider.addEventListener("input", function(){
        const meters = scale[radiusSlider.value];
        radiusValue.textContent =
        meters >= 1000 ? `${(meters / 1000).toLocaleString()} km` : `${meters} m`;


        //   radiusValue.textContent=this.value;
          if(userLocation){ 
              drawCircle(meters); 
              updateStatsForRadius(); 
              updateMarkers(commoditySelect.value,false); 
          }
      });

      // --- Fetch initial data ---
      try {
            const res = await fetch("/api/consumers_geojson/");
            if (!res.ok) throw new Error("Failed to fetch GeoJSON");
            allData = await res.json();  // <-- FIXED
            updateStatsForRadius(); 
            updateMarkers(commoditySelect.value, true);
        } catch(err){
            console.error("Error loading GeoJSON:", err);
        }

      commoditySelect.addEventListener("change", function(){
          selectedCommoditySpan.innerText=this.value;
          updateStatsForRadius();
          updateMarkers(this.value,true);
          
         
      });

            // --- Show total commodity count (case-insensitive) ---
        function updateCommodityCount() {
            if (!allData || !Array.isArray(allData.features)) return;
            const selectedCommodity = commoditySelect.value.trim().toLowerCase();

            const count = allData.features.filter(f =>
                f.properties?.commodity?.trim().toLowerCase() === selectedCommodity
            ).length;

            document.getElementById("commodityCount").innerText = 
                count > 0
                ? `Total Records: ${count}`
                : "No records found";
        }

        // Call initially and on change
        updateCommodityCount();
        commoditySelect.addEventListener("change", function(){
            selectedCommoditySpan.innerText=this.value;
            updateStatsForRadius();
            updateMarkers(this.value,true);
            updateCommodityCount();   // <-- added here
        });

      let districtLayer = null;

      const toggleDistrictBtn = document.getElementById("toggleDistrictBtn");
      let districtVisible = true;

       toggleDistrictBtn.addEventListener("click", () => {
          if(!districtLayer || !districtLayer.addTo) return; // safety check

          if(districtVisible){
              map.removeLayer(districtLayer);
              districtVisible = false;
              toggleDistrictBtn.innerText = "üó∫Ô∏è Show Districts";
          } else {
              districtLayer.addTo(map);
              districtVisible = true;
              toggleDistrictBtn.innerText = "üó∫Ô∏è Hide Districts";
          }
        });
      
        try {
              const districtResponse = await fetch("{% static 'districts_rev21june23.geojson' %}");
              const districtData = await districtResponse.json();
              
              districtLayer = L.geoJSON(districtData, {
                  style: { color: "#3388ff", weight: 2, fillOpacity: 0.1 }
              }).addTo(map); // initially visible
          } catch(err){
              console.error("Error loading district GeoJSON:", err);
          } 
        
       
      // --- Initial chart fetch ---
     
      document.getElementById('toggle-map-controls').addEventListener('click',()=>document.getElementById('map-controls').classList.toggle('collapsed'));

      function showTimeline(apmcName) {
        const url = `/apmc/${encodeURIComponent(apmcName)}/timeline-ajax/`;

        fetch(url)
            .then(res => res.text())
            .then(data => {
                const modalBody = document.querySelector('#apmcTimelineModal .modal-body');
                modalBody.innerHTML = data;

                // Show modal
                const modalEl = document.getElementById('apmcTimelineModal');
                const modal = new bootstrap.Modal(modalEl);
                modal.show();

                // Parse table rows
                const pricesRows = modalBody.querySelectorAll('tbody tr');
                const labels = [];
                const modalPrices = [];

                pricesRows.forEach(row => {
                    const date = row.cells[0].innerText;
                    const price = row.cells[6].innerText.replace(/,/g,'');
                    if(price){
                        labels.push(date);
                        modalPrices.push(parseFloat(price));
                    }
                });

                // Render chart after modal shown
                setTimeout(() => {
                    const ctx = modalBody.querySelector('#apmcTimelineChart').getContext('2d');

                    // Destroy previous chart only if it's a valid Chart instance
                    if(window.apmcTimelineChart instanceof Chart){
                        window.apmcTimelineChart.destroy();
                    }

                    window.apmcTimelineChart = new Chart(ctx, {
                        type: 'line',
                        data: {
                            labels: labels,
                            datasets: [{
                                label: 'Modal Price (‚Çπ/Quintal)',
                                data: modalPrices,
                                fill: false,
                                borderColor: 'rgba(75, 192, 192, 1)',
                                backgroundColor: 'rgba(75, 192, 192, 0.2)',
                                tension: 0.1
                            }]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            plugins: { legend: { position: 'top' }, title: { display: true, text: 'Modal Price Trend' } },
                            scales: {
                                x: { title: { display: true, text: 'Date' } },
                                y: { title: { display: true, text: 'Price (‚Çπ)' } }
                            }
                        }
                    });
                }, 200);

            })
            .catch(err => console.error(err));
    }

      // Attach event listener
      document.addEventListener('click', function(e){
        const target = e.target.closest('.apmc-link');
        if(target){
            e.preventDefault();
            const apmcName = target.dataset.apmc;
            showTimeline(apmcName);
        }
    });

   // Fetch Agmark Price and draw line chart
    let agmarkChart = null;
    let chartData = [];  // Store API response globally for tooltips
    let dateRangeSlider = document.getElementById('dateRangeSlider');
    let dateRangeLabel = document.getElementById('dateRangeLabel');

    document.getElementById("filterByDateBtn").addEventListener("click", async () => {
        const startDate = document.getElementById("startDate").value;
        const endDate = document.getElementById("endDate").value;
        const commodity = document.getElementById("commoditySelect").value;

        if (!commodity) return alert("Select a commodity first.");

        try {
            const url = `/api/webdata_prices/?commodity=${encodeURIComponent(commodity)}${startDate ? `&start_date=${startDate}` : ''}${endDate ? `&end_date=${endDate}` : ''}`;
            // const data = await fetch(url);
            const res = await fetch(url);
            const data = await res.json();

            if (data.error) {
                alert(data.error);
                return;
            }

            chartData = data;  // <-- Save globally for tooltip access

            // Extract labels and price arrays
            const labels = data.map(d =>{ 
                if(!d.date) return '';
                const dt = new Date(d.date);
                return dt.toLocaleDateString('en-GB');  // outputs DD/MM/YYYY
            });
            const minPrices = data.map(d => parseFloat(d.minprice));
            const maxPrices = data.map(d => parseFloat(d.maxprice));
            const modalPrices = data.map(d => parseFloat(d.modalprice));

            const ctx = document.getElementById("chartCanvas").getContext("2d");

            // Destroy previous chart
            if (agmarkChart instanceof Chart) agmarkChart.destroy();

            agmarkChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: labels,
                    datasets: [
                        { label: 'Min Price', data: minPrices, borderColor: 'green', tension: 0.3,borderWidth: 1, pointRadius: 2, pointHoverRadius: 8, pointBorderWidth: 1.5 },
                        { label: 'Max Price', data: maxPrices, borderColor: 'red', tension: 0.3,borderWidth: 1, pointRadius: 2, pointHoverRadius: 8, pointBorderWidth: 1.5},
                        { label: 'Modal Price', data: modalPrices, borderColor: 'blue', tension: 0.3,borderWidth: 1, pointRadius: 2, pointHoverRadius: 8, pointBorderWidth: 1.5}
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { position: 'top' },
                        title: { display: true, text: `${commodity} Price Trend per Qunital` },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    const price = context.raw;
                                    const datasetLabel = context.dataset.label;
                                    const index = context.dataIndex;
                                    const apmcName = chartData[index].apmc_name || "Unknown APMC";
                                    return `${datasetLabel}: ‚Çπ${price} (${apmcName})`;
                                }
                            }
                        }
                    },
                    scales: {
                        x: { title: { display: true, text: 'Date' } },
                        y: { title: { display: true, text: 'Price (‚Çπ)' } }
                    }
                }
            });
            
                   
        
        } catch(err){
            console.error("Error fetching webdata prices:", err);
            alert("Failed to load prices. Check console.");
        }
    });

 }//InitMap close
// --- Commodity count display ---
const token = sessionStorage.getItem("api_token");

const commoditySelect = document.getElementById("commoditySelect");
const commodityCount = document.getElementById("commodityCount");
const initialCommodity = commoditySelect?.value?.trim();

commoditySelect.addEventListener("change", () => {
// commoditySelect.addEventListener("change", async function () {
  const commodity = commoditySelect.value;
//   await updateAgmarkControls(commodity);

  if (!commodity) return;

  fetch(`/api/commodity_count/?commodity=${commodity}`, {
    headers: { "Authorization": `Bearer ${token}` } // if using JWT or session
  })
  .then(response => response.json())
  .then(data => {
    if (data.count !== undefined) {
      commodityCount.textContent = `${data.commodity}: ${data.count} records found`;
    } else {
      commodityCount.textContent = "Error fetching count.";
    }
  })
  .catch(err => {
    commodityCount.textContent = "Error connecting to server.";
    console.error(err);
  });
});
// --- Consumers1 Price Trend Chart ---
let consumersChart = null;

async function fetchConsumersPrices() {
  const commodity1 = document.getElementById("commoditySelect").value;
  const startDate1 = document.getElementById("startDate1").value;
  const endDate1 = document.getElementById("endDate1").value;

  if (!commodity1) return;

  try {
    const url = `/api/consumers1_prices/${encodeURIComponent(commodity1)}/?` +
      `${startDate1 ? `start_date=${startDate1}&` : ""}` +
      `${endDate1 ? `end_date=${endDate1}` : ""}`;

    const res = await fetch(url);

    if (!res.ok) {
      console.error("Fetch error:", res.statusText);
      return;
    }

    const data = await res.json();

    if (!Array.isArray(data)) {
      console.error("Unexpected API response:", data);
      Swal.fire({
        icon: "warning",
        title: "No consumer data",
        text: "The consumer price API did not return valid data.",
      });
      return;
    }

    // ‚úÖ Sort safely by date
    const sortedData = [...data].sort((a, b) => new Date(a.date) - new Date(b.date));

    const labels = sortedData.map(d => new Date(d.date).toLocaleDateString("en-GB"));
    const prices = sortedData.map(d => parseFloat(d.price));

    const ctx = document.getElementById("consumersChart").getContext("2d");

    if (consumersChart instanceof Chart) {
      consumersChart.destroy();
    }

    consumersChart = new Chart(ctx, {
      type: "line",
      data: {
        labels,
        datasets: [
          {
            label: "Consumer Reported Price (‚Çπ)",
            data: prices,
            borderColor: "rgba(255, 99, 132, 1)",
            backgroundColor: "rgba(255, 99, 132, 0.2)",
            borderWidth: 2,
            tension: 0.3,
          },
        ],
      },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        plugins: {
          title: {
            display: true,
            text: `Consumer Prices for ${commodity1}`,
          },
          legend: { position: "top" },
        },
        scales: {
          x: { title: { display: true, text: "Date" } },
          y: { title: { display: true, text: "Price (‚Çπ)" } },
        },
      },
    });
    // ‚úÖ Register for resize logic
    window.chartInstances = window.chartInstances || {};
    window.chartInstances["consumersChart"] = consumersChart;

  } catch (err) {
    console.error("Error fetching consumer prices:", err);
  }
}

// Attach to Filter button and commodity change
document.getElementById("filterByDateBtn1").addEventListener("click", fetchConsumersPrices);
document.getElementById("commoditySelect").addEventListener("change", fetchConsumersPrices);

// Initial load (optional)
fetchConsumersPrices();


// --- Farmer1 Price Trend Chart ---
let farmerChart = null;

async function fetchFarmersPrices() {
  const commodity2 = document.getElementById("commoditySelect").value;
  const startDate2 = document.getElementById("startDate2").value;
  const endDate2 = document.getElementById("endDate2").value;

  if (!commodity2) return;

  try {
    const url = `/api/farmers_prices/${encodeURIComponent(commodity2)}/?` +
      `${startDate2 ? `start_date=${startDate2}&` : ""}` +
      `${endDate2 ? `end_date=${endDate2}` : ""}`;

    const res = await fetch(url);

    if (!res.ok) {
      console.error("Fetch error:", res.statusText);
      return;
    }

    const data = await res.json();

    if (!Array.isArray(data)) {
      console.error("Unexpected API response:", data);
      Swal.fire({
        icon: "warning",
        title: "No Famer data",
        text: "The Farmer fetch price API did not return valid data.",
      });
      return;
    }

    // ‚úÖ Sort safely by date
    const sortedData = [...data].sort((a, b) => new Date(a.date) - new Date(b.date));

    const labels = sortedData.map(d => new Date(d.date).toLocaleDateString("en-GB"));
    const prices = sortedData.map(d => parseFloat(d.price));

    const ctx = document.getElementById("farmerChart").getContext("2d");

    if (farmerChart instanceof Chart) {
      farmerChart.destroy();
    }

    farmerChart = new Chart(ctx, {
      type: "line",
      data: {
        labels,
        datasets: [
          {
            label: "Famer's Reported Selling Price (‚Çπ)",
            data: prices,
            borderColor: "rgba(255, 99, 132, 1)",
            backgroundColor: "rgba(255, 99, 132, 0.2)",
            borderWidth: 2,
            tension: 0.3,
          },
        ],
      },
      options: {
        responsive: true,
        maintainAspectRatio: false,

        plugins: {
          title: {
            display: true,
            text: `Farmer's Selling Price for ${commodity2}`,
          },
          legend: { position: "top" },
        },
        scales: {
          x: { title: { display: true, text: "Date" } },
          y: { title: { display: true, text: "Price (‚Çπ)" } },
        },
      },
    });

  } catch (err) {
    console.error("Error fetching Farmer selling prices:", err);
  }
}

// Attach to Filter button and commodity change
document.getElementById("filterByDateBtn2").addEventListener("click", fetchFarmersPrices);
document.getElementById("commoditySelect").addEventListener("change", fetchFarmersPrices);

// Initial load (optional)
fetchFarmersPrices();
 

// Toggle Show/Hide for all trend charts
document.querySelectorAll('.toggle-chart-btn').forEach(btn => {
  btn.addEventListener('click', () => {
    const targetId = btn.dataset.target;
    const targetCanvas = document.getElementById(targetId);

    if (targetCanvas.style.display === 'none') {
      targetCanvas.style.display = 'block';
      btn.textContent = 'Hide';
    } else {
      targetCanvas.style.display = 'none';
      btn.textContent = 'Show';
    }
  });
});
//   // --- Resize Chart Logic ---
// // Resize Chart Button Logic
// document.querySelectorAll(".resize-chart-btn").forEach(btn => {
//   btn.addEventListener("click", () => {
//     const targetCanvasId = btn.dataset.target; // e.g. consumersChart
//     const container = document.getElementById(targetCanvasId + "Container");
//     if (!container) return;

//     const chartInstance = window.chartInstances?.[targetCanvasId];
//     const expanded = container.classList.toggle("expanded");
//     btn.textContent = expanded ? "Shrink" : "Expand";

//     setTimeout(() => {
//       chartInstance?.resize();
//     }, 100);
//   });
// // });
// const startInput = document.getElementById("startDate");
// const endInput = document.getElementById("endDate");
// const dateSlider = document.getElementById("dateSlider");
// const sliderStartLabel = document.getElementById("sliderStartLabel");
// const sliderEndLabel = document.getElementById("sliderEndLabel");
// const sliderValue = document.getElementById("sliderValue");

// // Convert date ‚Üî timestamp
// function dateToTime(d) {
//   return new Date(d).getTime();
// }
// function timeToDate(t) {
//   return new Date(t).toISOString().split("T")[0];
// }

// // Set slider range when start/end change
// function updateDateSliderRange() {
//   if (!startInput.value || !endInput.value) return;

//   const start = dateToTime(startInput.value);
//   const end = dateToTime(endInput.value);
//   const totalDays = Math.max(0, Math.floor((end - start) / (1000 * 60 * 60 * 24)));

//   dateSlider.min = 0;
//   dateSlider.max = totalDays;
//   dateSlider.value = 0;

//   sliderStartLabel.textContent = startInput.value;
//   sliderEndLabel.textContent = endInput.value;
//   sliderValue.textContent = startInput.value;
// }

// // When slider moves
// dateSlider.addEventListener("input", function () {
//   if (!startInput.value || !endInput.value) return;

//   const start = dateToTime(startInput.value);
//   const offset = parseInt(this.value);
//   const currentDate = timeToDate(start + offset * 24 * 60 * 60 * 1000);

//   sliderValue.textContent = currentDate;

//   // OPTIONAL: Update Agmark chart live for this date
//   // fetchAgmarkData(commoditySelect.value, startInput.value, currentDate);
// });

// // When date inputs change
// [startInput, endInput].forEach(inp => inp.addEventListener("change", updateDateSliderRange));

// // Initialize once
// updateDateSliderRange();
// --- Initialize Two-Way Date Range Slider ---
// =============================
// Two-way date range slider (Agmarknet)
// =============================
// const dateRangeSlider = document.getElementById('dateRangeSlider');
// const dateRangeLabel = document.getElementById('dateRangeLabel');

// // Define the min and max date for your dataset (adjust as needed)
// const allDates = agmarkData.map(d => new Date(d.date));
// const minDate = new Date(Math.min(...allDates));
// const maxDate = new Date(Math.max(...allDates));

// // const minDate = new Date("2023-01-01");
// // const maxDate = new Date("2025-12-31");

// // Initialize noUiSlider
// noUiSlider.create(dateRangeSlider, {
//   start: [minDate.getTime(), maxDate.getTime()],
//   connect: true,
//   range: {
//     min: minDate.getTime(),
//     max: maxDate.getTime()
//   },
//   step: 24 * 60 * 60 * 1000, // 1 day
//   tooltips: false,
// });

// // Function to format dates
// function formatDate(ts) {
//   const d = new Date(ts);
//   return d.toISOString().split('T')[0];
// }

// // Display initial range
// dateRangeLabel.textContent = `${formatDate(minDate)} ‚Äî ${formatDate(maxDate)}`;

// // Update display on slide
// dateRangeSlider.noUiSlider.on('update', function (values) {
//   const start = formatDate(+values[0]);
//   const end = formatDate(+values[1]);
//   dateRangeLabel.textContent = `${start} ‚Äî ${end}`;
// });

// // Optional: Trigger your filter when sliding stops
// dateRangeSlider.noUiSlider.on('change', function (values) {
//   const start = formatDate(+values[0]);
//   const end = formatDate(+values[1]);
  
//   console.log("Selected range:", start, "to", end);
//   // üîπ You can call your Agmarknet chart update function here:
//   // fetchAgmarkChart(start, end);
// });


let chartPopup = null;

document.getElementById("openAllChartsBtn").addEventListener("click", openAllChartsInPopup);

function openAllChartsInPopup() {
  const chartIds = ["consumersChart", "farmerChart", "chartCanvas"]; // all your chart <canvas> IDs
  const chartImages = chartIds.map(id => {
    const canvas = document.getElementById(id);
    return canvas ? canvas.toDataURL("image/png") : null;
  }).filter(Boolean);

  // Reuse popup if it‚Äôs already open
  if (!chartPopup || chartPopup.closed) {
    chartPopup = window.open("", "chartsPopup", "width=1100,height=900");
  } else {
    chartPopup.focus();
  }

  // Write content
  chartPopup.document.open();
  chartPopup.document.write(`
    <html>
      <head>
        <title>All Charts</title>
        <style>
          body {
            margin: 0;
            background: #f9fafb;
            font-family: Arial, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start;
            padding: 20px;
            gap: 20px;
          }
          img {
            max-width: 95%;
            border: 1px solid #ccc;
            border-radius: 8px;
            box-shadow: 0 0 10px rgba(0,0,0,0.1);
          }
          button {
            position: fixed;
            top: 10px;
            right: 10px;
            padding: 6px 12px;
            background: #007bff;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
          }
        </style>
      </head>
      <body>
        <button onclick="window.close()">Close</button>
        ${chartImages.map((src, i) => `<img src="${src}" alt="Chart ${i + 1}">`).join("")}
      </body>
    </html>
  `);
  chartPopup.document.close();
}
const labels = agmarkChart.data.labels; // e.g. ['2024-01-01', '2024-01-02', ...]




});
</script>
{% endblock %}